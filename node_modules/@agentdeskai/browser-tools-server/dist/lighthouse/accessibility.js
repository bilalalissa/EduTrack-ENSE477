import { AuditCategory } from "./types.js";
import { runLighthouseAudit } from "./index.js";
// Original limits were optimized for human consumption
// This ensures we always include critical issues while limiting less important ones
const DETAIL_LIMITS = {
    critical: Number.MAX_SAFE_INTEGER, // No limit for critical issues
    serious: 15, // Up to 15 items for serious issues
    moderate: 10, // Up to 10 items for moderate issues
    minor: 3, // Up to 3 items for minor issues
};
/**
 * Runs an accessibility audit on the specified URL
 * @param url The URL to audit
 * @returns Promise resolving to AI-optimized accessibility audit results
 */
export async function runAccessibilityAudit(url) {
    try {
        const lhr = await runLighthouseAudit(url, [AuditCategory.ACCESSIBILITY]);
        return extractAIOptimizedData(lhr, url);
    }
    catch (error) {
        throw new Error(`Accessibility audit failed: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Extract AI-optimized accessibility data from Lighthouse results
 */
const extractAIOptimizedData = (lhr, url) => {
    const categoryData = lhr.categories[AuditCategory.ACCESSIBILITY];
    const audits = lhr.audits || {};
    // Add metadata
    const metadata = {
        url,
        timestamp: lhr.fetchTime || new Date().toISOString(),
        device: "desktop", // This could be made configurable
        lighthouseVersion: lhr.lighthouseVersion,
    };
    // Initialize variables
    const issues = [];
    const criticalElements = [];
    const categories = {};
    // Count audits by type
    let failedCount = 0;
    let passedCount = 0;
    let manualCount = 0;
    let informativeCount = 0;
    let notApplicableCount = 0;
    // Process audit refs
    const auditRefs = categoryData?.auditRefs || [];
    // First pass: count audits by type and initialize categories
    auditRefs.forEach((ref) => {
        const audit = audits[ref.id];
        if (!audit)
            return;
        // Count by scoreDisplayMode
        if (audit.scoreDisplayMode === "manual") {
            manualCount++;
        }
        else if (audit.scoreDisplayMode === "informative") {
            informativeCount++;
        }
        else if (audit.scoreDisplayMode === "notApplicable") {
            notApplicableCount++;
        }
        else if (audit.score !== null) {
            // Binary pass/fail
            if (audit.score >= 0.9) {
                passedCount++;
            }
            else {
                failedCount++;
            }
        }
        // Process categories
        if (ref.group) {
            // Initialize category if not exists
            if (!categories[ref.group]) {
                categories[ref.group] = { score: 0, issues_count: 0 };
            }
            // Update category score and issues count
            if (audit.score !== null && audit.score < 0.9) {
                categories[ref.group].issues_count++;
            }
        }
    });
    // Second pass: process failed audits into AI-friendly format
    auditRefs
        .filter((ref) => {
        const audit = audits[ref.id];
        return audit && audit.score !== null && audit.score < 0.9;
    })
        .sort((a, b) => (b.weight || 0) - (a.weight || 0))
        // No limit on number of failed audits - we'll show them all
        .forEach((ref) => {
        const audit = audits[ref.id];
        // Determine impact level based on score and weight
        let impact = "moderate";
        if (audit.score === 0) {
            impact = "critical";
        }
        else if (audit.score !== null && audit.score <= 0.5) {
            impact = "serious";
        }
        else if (audit.score !== null && audit.score > 0.7) {
            impact = "minor";
        }
        // Create elements array
        const elements = [];
        if (audit.details) {
            const details = audit.details;
            if (details.items && Array.isArray(details.items)) {
                const items = details.items;
                // Apply limits based on impact level
                const itemLimit = DETAIL_LIMITS[impact];
                items.slice(0, itemLimit).forEach((item) => {
                    if (item.node) {
                        const element = {
                            selector: item.node.selector,
                            snippet: item.node.snippet,
                            label: item.node.nodeLabel,
                            issue_description: item.node.explanation || item.explanation,
                        };
                        if (item.value !== undefined) {
                            element.value = item.value;
                        }
                        elements.push(element);
                        // Add to critical elements if impact is critical or serious
                        if (impact === "critical" || impact === "serious") {
                            criticalElements.push(element);
                        }
                    }
                });
            }
        }
        // Create the issue
        const issue = {
            id: ref.id,
            title: audit.title,
            impact,
            category: ref.group || "other",
            elements: elements.length > 0 ? elements : undefined,
            score: audit.score,
        };
        issues.push(issue);
    });
    // Calculate overall score
    const score = Math.round((categoryData?.score || 0) * 100);
    // Generate prioritized recommendations
    const prioritized_recommendations = [];
    // Add category-specific recommendations
    Object.entries(categories)
        .filter(([_, data]) => data.issues_count > 0)
        .sort(([_, a], [__, b]) => b.issues_count - a.issues_count)
        .forEach(([category, data]) => {
        let recommendation = "";
        switch (category) {
            case "a11y-color-contrast":
                recommendation = "Improve color contrast for better readability";
                break;
            case "a11y-names-labels":
                recommendation = "Add proper labels to all interactive elements";
                break;
            case "a11y-aria":
                recommendation = "Fix ARIA attributes and roles";
                break;
            case "a11y-navigation":
                recommendation = "Improve keyboard navigation and focus management";
                break;
            case "a11y-language":
                recommendation = "Add proper language attributes to HTML";
                break;
            case "a11y-tables-lists":
                recommendation = "Fix table and list structures for screen readers";
                break;
            default:
                recommendation = `Fix ${data.issues_count} issues in ${category}`;
        }
        prioritized_recommendations.push(recommendation);
    });
    // Add specific high-impact recommendations
    if (issues.some((issue) => issue.id === "color-contrast")) {
        prioritized_recommendations.push("Fix low contrast text for better readability");
    }
    if (issues.some((issue) => issue.id === "document-title")) {
        prioritized_recommendations.push("Add a descriptive page title");
    }
    if (issues.some((issue) => issue.id === "image-alt")) {
        prioritized_recommendations.push("Add alt text to all images");
    }
    // Create the report content
    const reportContent = {
        score,
        audit_counts: {
            failed: failedCount,
            passed: passedCount,
            manual: manualCount,
            informative: informativeCount,
            not_applicable: notApplicableCount,
        },
        issues,
        categories,
        critical_elements: criticalElements,
        prioritized_recommendations: prioritized_recommendations.length > 0
            ? prioritized_recommendations
            : undefined,
    };
    // Return the full report following the LighthouseReport interface
    return {
        metadata,
        report: reportContent,
    };
};
