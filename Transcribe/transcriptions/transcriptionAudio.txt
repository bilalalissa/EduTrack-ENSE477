Source: lab1-aud-Rec.m4a
App: Transcription App
Date: 2024-11-01 22:56:40
Duration: 1h 38m 28s
Letters Count: 93343
Words Count: 17874

Outline:
- Introduction
- Key Points
- Conclusion

 of kind of view on network programming works. So first of all, we'll have through the syllabus. If you haven't already, please go to your courses. And all the important stuff should be at the bottom here. I guess we do this lab one. We're not thinking today. And we'll also want to grab our lab one doc. But first we'll need to go through the syllabus. Stuff here, probably everybody knows me. I hear you mostly from being capstone. If not, Adam Delson, Master of Flight Science, the end, did all my degrees here. So we're trying to pursue, I guess, least job versus job versus job versus job. I'm trying to pursue now. I can need to contact you by office. Just send an email and we'll set something up. This is our call to 2024 term. We are meeting Friday's 8.30 AM to 11.15, but only going to be five labs. We'll look at the schedule and to set here. And the purpose of this lab is to keep your understanding of digital network programming and perspective of the software systems engineer. There's a lot of different ways to look at this. We look at it from the hardware side, or operating system side. Looking kind of top down, we are still going to need to go a little bit low from time to time. But we'll end up someone in the middle, I guess. Is there a open speaker? Yeah, do you want to mute or something? So we don't get to end up with a feedback loop. Yeah, so in particular, we're going to look at low level network programming and Python. We look at exploring packets, starting to look at some higher level stuff, some modeling stuff. And eventually, we'll do some network programming to get out. So policies you might want to know about. First of all, is the late submission policy. So once you're submitting your course, you're going to have a base week for submission. I can submit up to one week late, until I see classes. I mean, to provide any rationale, just let me know you're using the base week. So that we let the TA know. Next up is our group work policy. So for this one, we are going to allow working with partner. I don't know why we do that. We do that. So basically, at the beginning of the semester, you can pick a partner, work with them, do one submission, receive one grade, everything is good there. I need to keep the same partner all semester. But if it's not working out, the team can split up at any point. But then you just are not allowed to re-part their backup after that. Any code you submit, new spirit and value in this course. So exception of course, brief snippets from people's code you find online. If it's not solving a core part of the problem, just using a head do something like loop over a list or something, obviously you're going to follow the tutorial and figure out how to do that. So that's certainly a ton of trouble. Obviously, you've used a copy of the people's code. That's the way code works. But higher level, obviously, you're not allowed to do that. If you have any accessibility requirements, please reach out to the Accessibility Center. It's possible. And official modality for this course is going to be on the in-person. But if you want to zoom in, I will. I will. I will. I will. I'm looking for most people are this. I assume that's because they're getting more than 1,000 or 1,000 people out of town. OK, so let's head to the first one. I guess I'll walk pretty quick through the syllabus. But I'm sure you guys have seen a bullet punch these by now. My name is Sushana. Sushana's concerns. Concerns. Yes, there's blood. Shots. Shots. Like nothing. OK. On to looking at the first lap. And I'm like, I say this might be a long way to go. I think they're very good to work. So the idea here is we want to introduce you to low-level network programming in some language. Could have done C or C++, like an operating system class would do. But I thought it was a bit better idea probably to do Python. So look at low-level network programming in Python. That's going to require a decent amount of stuff. We're probably going to want to have a quick primer on Python. I think everybody should know a decent amount from this if you take in my 350 class or any of the machine learning or AI classes. Up just in case not, we will run through just some kind of basics of the language. So you're kind of aware of it. Then we'll head into doing some inter-process communication stuff, just kind of a high-level overview of it. So understanding client server architecture protocols. And we'll talk a little bit about low-level versus high-level APIs. Then the technical things we want to do are sockets and asynchronous functions basically using threads. So there's a decent amount here to do. Again, like I say, we're going to be a long one. Lots of coding. So hopefully, keep you awake anyway. So in this lab, we're going to investigate network programming by creating a simple chat application in Python. However, to get there, we're going to need to look at a lot. Sockets, low-level code, which is kind of similar to C or C plus plus interfaces on Unix. But a bit easier to work with. We'll also look at how network communication works from top down approach, starting with programs, and then moving through the different layers of the network stack as we need to to understand things. Won't really dive too deep into anything for this one. I think it's sort of overview at this level. And then you'll fill things out both in the class and other labs. Part of the reason we're doing this is that, I guess it's kind of crags mentality. But I guess a little bit mine, too, is that as software systems engineers, you are understanding to expect sort of the entire system from the program you are writing all the way down to bare wire. And so sometimes that involves debugging, like say a network. And so that might mean debugging code. It might mean debugging hardware. It might mean debugging all sorts of different things. That's sort of understanding all of these different aspects of networking, is really valuable for you in this field. OK, so let's head on to our quick primer on Python. So this will be very similar to the 350 warmup. If you've taken 350 with me, should be available on your courses. So I've grabbed it here already. Let's go ahead and unzip it. Maybe try something to upset it. So usually with my warmups, I have both a kind of an initial one and a complete one. I really hate that it has shown me my file extensions super irritating. Well, we'll take it for this out. Shifting the terrible infeed instead. Give me one second here. I want to show that these are my files. I hate extensions for no one's files. Never. Yeah, so anyways, these are Python files with the dot CY. If you've only ever used Python through Jopro Notebooks, this will be a little bit different, right? These are essentially files that we can run from the command line Python by interpreter. Then we pass the script name after that and just go to head and runs it. So we're going to work through the warmup one together today. Let's go to the open up code. And I also have the warmup complete one here as well. So if you fall behind anything recording together today, that will be available for you there. Please ignore all this stuff. That's a different one. Sure, I trust myself. So yeah, and I might scrap my complete one and pull it over to a second monitor so I can just go ahead and do that. Sure does. So that I can kind of follow along with it too. Yeah, we're just going to warm up to Python the way that it works again. So we just do kind of piece by piece here. I can pair it for now. So we're going to start by printing hello world. Now it's quite a bit going on down here. So I might just comment out once a bit. So it's not all printing for us here. Uncomment as we go. So begin with printing out hello world and Python is just printing hello world. I'm going to open up a terminal. Hopefully it's in the same place. Sure is. Should be seeing our two files here. So to run your Python file, you might need to install Python if you're at home. If you are at home and don't have Python, just. Is it just python.org? And you want to grab whatever the Python 3 build is. So it looks like a 3.12.6. I typically am only using like 3.10 on a most of my machine. So hopefully everything works kind of forward. I'll have to test it my school, I guess, to make sure it's all working. Because I know the machines here are running 3.12. Oh yeah. So once you install it, you can then run your program using Python and then the name of the file. So the NSE 472.1 warmup.py. And we're just getting our little hello world from the school's first part running here. So let's look at some basics with numbers next. So let's go ahead and do some simple numerical operations. So you can do regular like math type things in Python. That's all fine, right? All the kind of things you'd expect. I think you're gonna work just fine in the Python world. You can see if we're doing our 1 plus 1, we're getting our 2, 4 times 3 is getting 12. Normal type of stuff. First thing that might be a little different compared to like C plus plus is that Python uses float division by default. I guess they were kind of going based on the idea of, most people come to programming from a math background. So it makes sense that numbers work the same way in the Python world as they do in the math world. C plus plus does not assume that ever. They basically assume you learn the programming way and it goes from there. If Python's not always that way, but this is I guess an example of it. If you do need to do those kind of C plus plusy type operations, the quotient part is like the 17 and the double slash five. And the remainder or modulo is still the percent sum. We do 17, double slash five. That should be 17 into five is two remainder, two, three remainder, two. So the first part should be three and the second part should be two, right? So the comma here is just kind of passing two arguments into print, which will print out both things. So yeah, three remainder two, right? Let's look at some string operations in Python next. So string concatenations are pretty straightforward. You can use the plus sign for these. Some of this will probably need to do when you're doing your chat thing a little bit later today. Lots of different ways you can terminate strings in Python's. We'll kind of show you three of them. We have hello, we have space and we have world. All three of these are valid ways of doing strings. I believe the triple quotes are for the multi line strings. We'll just try that out. So you can see that it's doing hello world here concatenating the two parts together. But let's just go ahead and see, you know, multi line strings had some spaces in there. And now we should get hello world. So kind of useful sometimes. There are those amazing F strings too. I don't think I have a thing for him here. Fortunately, it's kind of too bad. Do you remember how those work in Python off the top? My head, I might not. A prior to review that before I try and weaunt. But basically you do the F at the beginning and then you added some places where you want to substitute in variables and then you put the variables in the after and sort of subs them in. That's kind of cool. OK, let's head on to string repetition next. Yeah, number one thing that I use and don't teach F strings. Probably should start teaching it. OK, so let's head into string repetition. So again, this might be valuable to you in your some of the things we're doing today. So a little bit strange. If you use the multiply sign after a string, it will basically just repeat the string that number of times. I don't know why that's a thing, but it is a thing. So interesting, I guess. String slices also kind of interesting. This is sort of a equivalent to doing like list slices or maybe I guess the substring method of in C++ is maybe the best equivalent to it. So if you remember substring from C++ to typically specify where you want to start and how far you want to go. So we'll start by having our hello world here. And then we want to start at 1, 2, 3. So I think element 3 would be the second L. And looks like I want to go to 7 in my doc. So I'm thinking that's going to be, so starting at 3, do I remember how this works? This go to number 7 is this grab 7 things. I don't remember. I'm just going to run it. And I guess we'll figure it out. Doesn't like something I did here. Why does it not like this? Do they no longer let me use this syntax directly in the browser? Not Tupel. Oh, should be it. One of these things I've said, slices use the code in them. So yeah, this should start at number 3. And I guess go to number 7. 3 is inclusive 7 is x-books. So 0, 1, 2. So we start at number 3, 4, 5, 6, 7 would be the O, and we're excluding it. So let's move on to lists next. Also super duper valuable lists are just your collections of different elements, typically the same type. Don't necessarily need to be, but generally makes more sense to have them the same type. So we can make our list like that, or we can maybe put in a variable first call list, new list, and all that. Oh, look at this style. What's this? And we'll print it on a list. And this is basically our equivalent to an array, right? I would really like to introduce the idea of kind of looking for the help on different functions. Just you can kind of see how this works. So typically the thing we want to do here is we want to call this DIR function on new list. And this is the way that you'll be able to see, this not work on a... Maybe it's not work in a... Okay, there we go. So yeah, basically this is showing you all of the functions that are available in the list type, right? Any of these ones with double underscores before and after, these are like helper functions or privates. These are things that Python lets you use, you're probably really not supposed to do anything like... Well, most of these are just going to be a different way to access it, right? Like DIR, we figured that one out, right? We did that by calling DIR in front of it, right? And you invoke that with the plus sign, right? Less than or equals to, that would be the less than or equal to sign, right? So most of these are just gonna be some other way you can access them as well. The ones at the bottom here that are named, these are the ones that they expect you to use, right? So we want to do something like inserting or popping that kind of thing, that's where that would go. So I guess I should just put that over down here. Other thing, if you want to know a little bit more info about one of these things, you can call help on it. Again, I don't know if I need to print this guy out or not, so let's try it out. Let's do a help on a new list.insert. I might need to print this out for my shirt. Yeah, it's trying to call more, let's try doing an printed save list works. Might be the kind of thing you need to call from the shell directly, not short. Yeah, so you'd probably need to call this from the shell directly. So if you had like a Python thing going here, you had a new list equals one, two, three, and then you want to do a help on newlist.insert. You'd be able to see it. Oh, I guess they just strip, do not have more available on this computer. That's very strange. Yeah, guess we're probably not going to be able to use this directly in the lab environment for whatever reason. Lab environment decently cursed. Seems like it's getting more cursed or rear. I suppose your backup would always be just to head to the official docs, right? Look up Python list, probably W3 schools or the Python docs. Either one is going to have basically what you need to understand how things work. I'm going to be able to give you a little bit of a rundown on some of these functions. That kind of thing as well. It is built in, but I guess this is what we would see if we had the access to the help function, right? If we did the help on list insert, it would have told us all this stuff. Insert an item at a given position, first argument is where, second argument is what, all that kind of stuff, right? Okay, so comment this guy out, because it's not going to work for us. We're past this guy, past this guy. I kind of skipped these two. I didn't skip them, but did them. So let's go ahead and append something to our list then. So appending to our list would be, would be something like new list dot, my dirt thing append looks like it is the name of the function. And, and let's just toss in the number six here. And if we rerun, oh, I'm still on this thing. Let's leave this guy. I append it, but I don't think actually did anything there. Let's go ahead and print it out. Oh, yeah, we don't want to print out for this thing. We want to append it and then print out our new list after. We should have going from one all the way up to six now. So not a ton more actually, but I'm going halfway. There's brief intro to by thought. So quite a bit more to go here. Let's hop into two pulls next. So two pulls are our immutable data structures, kind of similar to structs from C++. We use the round brackets for them. So if we had like a two pull T is going to be one and three, something like that. We could print our two pull T. These are typically used when you're passing multiple arguments to functions or returning them. Two pulls kind of like an intermediate data structure that you tend to use to pass things in and out. Sometimes you want to break them up afterwards. But once this kind of put together, it's stuck. You can't change it. You just have to break it completely apart again. Assign everything to a variable that you could change things. So when you run this, we should just see our two pulls always written with the curly round brackets. You can add, they are readable. So you can read, like that'll say element zero. We went out our two pull T and we want to read element zero. We'll go to grab that and that'll be our first index. That'll be number one. If you wanted to try to write to element zero, it's not going to work. If we try doing a two pull T zero and try to sign it to one, I guess already is one. Try to sign it to four. It's not going to work for us. It's just going to say that it's a type error. Two pulls do not support assignment. So yeah, not the right data structure for that type of work. So I'll just comment that guy out. Dictionaries are probably my favorite data structure in Python. This is a kind of a unique structure. I guess there are equivalents and basically, basically, every language that you typically don't learn them right away, things like hash maps or array lists or whatever they might be. Basically, there are keys and the associated certain valuables. The keys are immutable. The values are immutable. So let's go ahead and make a new dictionary. We'll call it DictDictUnderScoreD. Basically, at the point where I almost want to switch over to my other, yeah, anyway, at the point where I want to switch over to the completed barf and stop typing because there's a lot of typing here. But that's what we really want to do. So I'm just going to switch over to the completed one. We're picking up here at dictionaries. So I'm just going to go ahead and comment out. Everything that's here to follow. You guys have the completed one as well in your folder. So we're just going to look at little pieces by pieces. Here's our dictionary D. It starts with the curly bracket. And this is our key side. Key side is A. And then the value side is aqua. We will just format it like this. So it's a little bit easier to read keys and value parts. So very similar to a JavaScript object. A maps to aqua, B maps, blue, C maps to Cn. So we print out our DictD. Grab our complete one. Hopefully nothing's broken in it. Yeah, it's just printing it out kind of a human readable format here so we can see that's there. We can change the values for existing keys. Oh, this is uncommented out. So we're changing the value of A to a Lizarin, B to Burgundy, and C to Crimson. Just go ahead and do this. And you see that now they are remapped. So you can change what maps to what, I guess, something that's pointing to map to something else, right? Branching in Python, again, this is got a Y Y to switch to just uncommenting and looking at the code because it's getting brutally long to type. So the if statements in Python, kind of core part you want to remember is that they start with the keyword if LF4 else. You have your check in here. Rackets are totally optional. I don't know why I put them in there. I guess I was just being kind of like a bracket overkill. So if X is equal to 4, we were going to print X as 4. LFX is equal to 5. We'll print X as 5. Also, we'll print it as neither. So if we do this right now, we're setting X to 4. This one's going to trigger. And so we should print this guy out. Let's just confirm that is true with saying X as 4. If we change this guy to 5, we should see us popping into the second case here, the LF case. And number 6 would drop in straight into the L skits, right? Yeah, only important thing to really note is your spacing needs to be consistent for whatever thing you choose to do. So I think if I chose to do two, it'd be fine. I just need to be consistent, right? I don't think one is OK. I feel like one is probably not OK. So guess, maybe it's OK. Let's find out. It's fine if it's one OK. Apparently it's OK. I probably wouldn't use one. That seems a little bit too sketchy to me. But tabs should also be OK as long as you're consistent, right? So and I think my right now have it mapping so that tabs just turn space anyway. So if I were to do something first like this, delete this back by two. So now they're all kind of off by a little bit. Maybe I'll have two more here. They're all out of sync. I thought it should not like this. Apparently it's letting me get away with it. It really shouldn't be. Usually it doesn't. So that's interesting. Maybe they've gotten more permissive in what they let you do with indenting. But yeah, historically, this was never a thing, right? As soon as the indents don't match, you're going to have a bad time. So probably you're going to see that happen. OK, so let's hop onto loops next. So first type of loop we typically look at in Python because it's the most Pythonic type is the four in loop. So for some iterator in some, or I guess not really an iterator, will be the term. Basically, what this does is we take some data structure like a list here. We unpack that data structure. And we have some temporary variable that always points to the first thing that has been unpacked. Or the next thing that's been unpacked, right? So basically if we have this list, 1, 2, 3, 5, 7, we're going to unpack the one and sort in a number. We're going to print out number. Then we're going to move to the next guy, 2, unpack the two, start a number and print out number, 3, 4, 5, all that kind of thing. So it should be pretty straightforward. 1, 2, 3, 5, 7. Of course, because this is like a temporary variable, doesn't not support assignment, right? So we then set number to 4. That would overwrite the temporary variable each time. Let's just print out our order or list again at the end to see if anything has changed. Should not have changed. So yeah, you can see that even though we unpacked the thing into a number, we was overruled the number to 4. Maybe I'll just move this guy down instead. So we're seeing that 4 is being overwritten every time. Even though the number is being overwritten with 4 every time, it's not touching the original data structure. Because again, they're being unpacked, stored in a temporary variable, and then that temporary variable is discarded. So you can't think of it kind of like a function, right? Functions where we're passing by value. OK, we also have the ability to do wild loops, generally speaking, when you're just coding in the zone, you might have your logic in the wild loop format. So pretty straightforward. While I'll start to do off your comparator, make sure you are initializing your comparator before and incrementing it somewhere in or wild loops aren't always used with iterators. Sometimes they're used with other conditional logic too, right? So again, just make sure there is some way to break out of your wild loop inside unless you're looking for like a wild, wild true. The glorious wild true loop, because you might not have be capital to TRUE. You're not going to be looking at some good code when you see that. We'll see some of that today. So spoiler for some fun things that are going to happen. We also have our range-based for loops. This is basically what replaces the idea of like the numerical for loop, the kind of one in C plus plus, it's like for int i equals to 0. i is less than 6 i plus plus. Basically, all that type of stuff is captured in this one little line here. So for i and range 6, i will start at 0 and it'll go up to but exclude 6. So if we run this guy, we should see it printing out all the way 0, up to and excluding 6. So there will be six total numbers. There's always going to be the number you have here. But it's going to be 0 to 5, right? Kind of shift it down by 1. The range function, if you dig into it, actually has the ability to kind of set up all these things, right? You can set up your starter, you can set up your ending, and you can set up your step. Do I remember how they all work? If we do the first one, does that change our starter? Let's see. Yeah, so first one, I guess, is changing our starter and maybe the second one is step. Let's try it. Let's step two. See what happens. Yeah, so now we're going starting at one, doing three, doing five. We're still less than six, right? So I guess what is this? This is in i is equal to one. i is less than six. i plus equals two. I guess that's what we're doing with this guy, right? So again, everything is there, I suppose, just a little bit different than in C plus plus world. We have our functions as well. Functions start with the keyword death, then they have the name, and then they have arguments optional, and then they have the return statements inside. They use the same little spacey outing thing. So we will go ahead and call this guy and pass in square of three, and that will give us out nine here. So hopefully that is, I lost my thing. I hope that all makes sense. There is some object oriented programming stuff. I don't know if we're going to need to touch on that in this lab. I haven't reviewed all the labs in this class this year. I made these last year, so I should be all that far off from me. But yeah, basically key things to note is we have a constructor function, which is called init. We can have our, what do you call them? Like class variables. These we get created right in the constructor function. I'm going to use the keyword self to show that this is something that belongs to the class. So like this, for example, one of those constructors where you pass in name and then they get stored inside the class, you pass an age, it gets stored inside the class. Then later on in all the other functions, you can grab these things out. There's this weird syntax. We have to use the word self as the first argument of every function when you're creating it, but not when you're calling it, which again, a little bit irritating. So like, for example, we'll create Adam as a person, so I guess it was age 50 when I was making this, not 50 yet, I hope. So yeah, again, see how the self-part isn't really here. In my mind, I always kind of think like, okay, so self belongs to the class. So that's where the self-parts coming from, and everything else that falls. The thing we have in our brief intro is libraries. We'll need to use some libraries in this lab. So the keyword for that is import, then the name of the library. You need to look up the libraries to see what they are and all the many functions inside. For example, the math would have your square root functions, which you might need for doing square roots. So very, very quick 30-minute-ish intro to Python. Hopefully all refresher for people. Hopefully you're awake now. So we'll get into the new stuff, which will be hopefully a little bit more interesting. Let me just close some of this. I was trying to make a PDF open in Firefox, and I see that somebody has explicitly disabled that on all these machines. So that's interesting, kind of irritating. Yeah, what do we need to talk about? Let's start by talking about our kind of network basics review. So this is all kind of overview stuff. Probably a review of things Craig has been talking about. I might be a little bit ahead of him in some places. Might be behind in other places, but that's probably fine. So yeah, basically a network program, and what we're doing is interprocess communication. We're creating a bunch of different programs, and they're interacting with each other. Sometimes they're interacting on the same machine. Sometimes they're interacting on different machines across the world over some type of a network. But the kind of the important part with interprocess communication is that programs tend to hang up if they're just waiting on one thing. Then they do the one thing and get back. And so these days we tend to write our program using threads and maybe shared memory. So our programs they're acting like servers aren't hanging up. They're not just waiting for a thing and then doing a thing. We're able to maybe service multiple requests from different people at the same time. Right? So what a few different concepts we need to quickly chat about just to get some context for this lab. First is the idea of a client. So a client is a device or application which initiates a request. Their request is then handled by a server. Often clients are things that a user initiates. If our browser is a client and I'm going to Google, Google, I am a human who initiated that interaction. So I was a client and I got the feedback. Not always though. You might have a time lookup thing on your computer that just every hour or two it synchronized its clock with a remote one. You didn't have to do it. It was an automated thing but it still happened. Or a DNS lookup happens behind the scenes. Probably a human initiates it by starting a URL request. But not always right. It might be behind the scenes. So to contrast that we have our server side server size the device or application which responds to request made by clients. This is typically something that's running all the time. Maybe running as a service in the background we call that a demon or service I guess. Basically a program that just you don't really see it's happening but it's just there doing its thing in the background. One client then needs to initiate communication with the server and based on this selected protocol it will send some data, get some data back. That kind of thing. So web servers DNS servers, time servers, game servers I'm sure you've used these before. Probably programmed them in some of the classes as well. There's a much higher level right. So clients can talk to your servers. Multiple clients can talk to servers. They could be running on the same device. So your client and your server are running on the same post computer. That's totally fine. So I guess one of the kind of main questions people will ask is why do we tend to do a server client architecture versus a client only architecture. And one of the rationale behind this is it tends to be a lot fewer connections. If we're doing something totally peer to peer, a swarm like this you can see that everybody needs to know what everybody can interact with everybody. That's a lot of connections. If you're using a server one person sends the server and then they distribute out to everyone else. So if you're thinking of this like a multiplayer game you're playing, usually one player is posting the game. They're the server. They may be playing as well, but they're definitely the server. And every other player is just a client. And so generally speaking there's going to be some rules in the game of who has the ground truth and each piece of knowledge. But regardless everyone will send their truth to the server and the server will distribute that truth to everyone else. There might be certain times where client to client connections are made as well, but generally speaking this is going to be more efficient. I guess fewer connections. Less headache that way. Less concern about like firewalls and issues like that. So here's the example was a first person shooter with 100 players, right? Client server model. We need 100 connections. Client to client model. We need 99 connections plus 98 more plus 97 more plus whatever, right? Get some sane real fast. So then a couple of things. So if we're deciding that we're not running on the same computer or running over some type of a network, we're need to find some way to figure out who we're talking to. So like what device and maybe also which particular program. I'm so sorry, addressing is all about addressing as a way to uniquely identify which device is initiating a request. And there's a bunch of different methods for doing this. We have our public IP's private IP's IPv6 MAC addresses. And all these have different benefits and use cases. Usually they correspond to different layers of the network model. The simplest configuration is two devices on a local area network, each with a different IP address. And that package has been a long ethernet, except only by the host with the mask, matching ethernet address, right? Our IP address. So basically, kind of thinking of it like a big piece of wire that every computer is connected to. I put my request on the wire. Everyone sees it instantly. We check if it matches my address, but doesn't. We just say, not for me, ignore it. And but if it does match my address, I'll pick it up, unpack it, figure out who gets it. So it can be pretty complicated though. You don't just need to be working on a bear wire. You could be working on something like the internet where instead of your requesting in the network, it hops out to a router, which maybe then goes to another router, another router, another router, another network again, and then heads back into the server that way too. So when we're doing like a Google request, that's what's basically have to care, right? Doing all that kind of stuff. If you do some trace route, trace RT thing, as you can actually see the pathway to the computer that's being made. Yeah, for now, we're basically going to be working on the same device to start with here in the lab just for prototyping applications. Once again, to the simulation side of things, then we'll start being a little bit more complicated than that. We're not going to do any hardware in this lab. It's all going to be simulated because I think software engineering, probably more interesting to see the visualized what's happening and put right the programs, rather than actually physically play with it. If you want to physically play with it, I'm pretty sure Electronics offers a class that is like this one, but hardware focuss rather than software focuss. Next thing to talk about is works. So once we get a packet, how do we know who this packet belongs to? And that's what ports are all about. Port are like every program that's running can claim a port. Some are like reserved. They expect a certain service to be using them. Others are free for all. Anyone can have it. 65,535 total ports. By convention, some of these are alcheta services like 80s HDB, 22s SSH, 443s HDBS. That type of thing. There's one for a mail server, all kinds of things like that. But there's other ports that have no service associated with them. And typically those are above 1024. Those are usually free to do whatever. So for example, on a server, we might have the HDB, HDBS running on the server side at 443. On a client, we might have a bunch of different Firefox's running and they might be on random high ports. In fact, every tab I have opened here, if I had two tabs open here, and this tab I type in google.com, I want the response to come to this tab. I don't want it to go to this tab. So we're going to need to have two different ports running even on this computer just for this one little task I'm doing. So yeah, for example, on our client, we have 52197 is Firefox, which is shooting off to 443 over here. So you can kind of think of it like street addresses and apartments or suites, I guess. So your IP address is your street address and then your port is like your suite. Career apartment number, right? Maybe this is final English protocols, but we also have sockets and threats. So protocols are actually going to talk about. So once we have a communication pathway going, it's usually not enough to just send raw bits because like, you know, what are these raw bits even? So we need to do a set up some type of set of rules for what these bits are going to indicate. And that's where our protocols are, right? There are set of rules to dictate how devices will behave and interact with each other, right? So for example, the TCP protocol, you'll probably talk about this at some point in the class. This is a reliability protocol versus UDP, which is all about speed. So like TCP would be used by like web browser where you want to get your files back for sure. UDP would be used by like torrent where you're like, ah, I'll send the file. If it doesn't make it there, I'll just send it again. Or I'll ask for the file and if I don't get, I'll just ask again, right? It's nobody really cares. We'd rather have the speed than all this stuff, right? So depending on the protocol, a single transmitted message, like for example, Hello World, a representative bytes may be broken up into a number of different packets. And may even include some packs or purely control information, right? So even though we just want to send the world Hello World, which we know would be each of these is going to be, let's say it's ASCII, so each of these is going to be a byte, right? 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 11 bytes. If we're using something like UDP, it might be basically 11 or maybe 12 or 13, a couple for addressing. And then basically we're setting the message, right? So maybe like 13 bytes, so we've set the entire message over. If we're doing TCP, it might be like, ah, no 42 bytes, right? We're over half of the message is just initiating the communication protocol and making sure everything's working, setting the data, making sure it's received, right? So inefficient for sure, but guarantees reliability, right? So yeah, for example, a very simple protocol we could write would be one where we do something like say, hey, I'm going to send you some characters. I'm going to send you three characters, server's going to get it, okay? Got it. And then you're going to send the three characters, very, very simple protocol. I believe we're going to implement this together in one of our examples going forward. So that is protocols. Next we're going to talk about our sockets. So sockets are an application level. This is kind of like what we're when you're writing an app and you want to use one of these ports. Sockets is the mechanism that we use for doing that. It's a bidirectional communication endpoint, so each application is going to have one. So each of two applications, which connect will create a socket. So a client will create a socket, a server will create a socket, they'll connect to each other's sockets. So they'll need some things to do that, right? IP address, who are you? Port, which thing are we in and protocol, kind of what language are we speaking, right? And then once that's been established, the two devices may send data back and forth between the applications. So there's kind of example of some of the Python functions you'd want to call in order to set this up. So the client would go ahead and initialize their socket and then the server would initialize their socket as well. The server would do bind, which basically attaches, I think an IP address or a port to it permanently, not 100% sure, will investigate in a sec. Then it listens for a request and then it accepts requests. When it accepts requests, we go ahead and start a new thread. The client side does connect, which is what connects makes the connection. And then a client might do a send and the server might do a receive process. Now the server can do sends, the client can do receives. And then we have to make sure we close our socket as well. So two things to note here, we have socket tapping. We also have threads happening. Thread starts here on the server and ends down here. Clients don't typically need to run in threads because it's just going to be one thing, doing one thing, right? Once I type in Google onto here, I'm not really trying to do anything else. It can just sit there waiting until Google spawns, right? But on the Google side, they can't, right? They can't be like, oh, this one person wants a thing, okay? I'm going to shut down everything and handle them. No one else. It has to be able to steer responsive to like the billions of people across the world that are sending these requests. Okay, so last couple of things to talk about in our just sort of chatting zone. Packets is the next one. So to make a network communication more effective data, maybe split into smaller chunks called packets. And we'll look at that later labs. Last thing is threads. I guess we also have been coding as well, but I should know about that. So threads is kind of maybe new to you, maybe not depending on what class is you've taken. So thread is the smallest part of a program which can run independently. We can think of it like a single function, which will be created and run independently until it's completed, then it'll join back into the program. The advantage of threads is that their execution scheduling is how by the operating systems, ensure the system remains responsive. So all the threads can finish in a timely manner. So on our server side, we're going to be wanting to do threads for handling all the requests every time in your request is made, spot a new thread. And then that will do with one of the many people communicating. tricky part of threads, tits tends to be sharing data because there can be what's called a race condition when multiple pieces or multiple threads try and access the same piece of data at the same time. And so let's look at some examples of that. In case you haven't seen this in other classes, I think it's getting to be more core. So guys will for sure be getting this in other classes soon, if not already. But so here's an example of a happy case. We're spawning up two threads. We're calling it client A handler and client B handler. So our server has number of clients is zero. Client A handler reads their number of clients is zero. Increments it by one. It writes that back and now number of clients is one. Then another client connects client B handler spons up. Increments it by two. It writes it back. And now our number of clients is two. So it's variable on the server side. They just keep in track of maybe how many people are in the lobby. It's going to be very accurate in this case as long as everybody kind of takes their turn. It comes at the same time. What happens if two people come at the exact same second, a thread spawns at the same time. And there isn't really anything that prevents reading and writing from happening kind of concurrently. Well, what would happen here is we have our number of clients at zero. Right. Client A is going to connect. So we're going to spawn up client A handler. It's going to read that number of clients variable. Cell says zero. B will read as well. Also says zero. Right. Then A is going to increment up to one. So because it's going to increase internal one, the one it read in. Right. Kind of like an internal to the thread. Did it with B. It's going to increment its internal one of the thread. Remember it also wrote in zero. So it's going to bump it up to one. Then A is going to write back one to here. And now it's going to say our number of clients is one, which we know is not true. Right. We know we have two clients to join, but just the order of reading and preventing writing can kind of mess everything up. And so different languages have different mechanisms for preventing against this semaphores mute X's whatever. I thought it's called lock is the name of the mechanism that prevents this. And basically what this means is that if a piece of a variable is locked and somebody tries to read a lock thing, they're not going to be able to they just have to wait their turn until the lock is open. So here's kind of our our nasty case with using locks. So number of clients is zero. So now client A read number of clients is zero. As soon as it reads it, it locks it. We can say that's an atomic operation. Their program in such a way that they can't get in between reading and locking. So now it's locked, right. So client B reads it. It sees this locked. So it can't do anything. It says I'm just going to try again. So I'll client A goes ahead and increments it by one still locked. Client B tries reading again. I can't. It's still locked. I will try again later. Client A writes back number one and unlocks it again. Assume that's atomic. Now when client B tries to read it, it sees it's unlocked or reads it in. Locks it. Bumps it up by one. Unlocks it. Unlocks it. And now we're up to two. So. We'll be looking at examples of using threads for doing things like broadcasting messages. Oh, I guess I guess I'm saying sometimes important for your main thread to broadcast message user each of your sub threads. This is usually done with threat events signals. We can't remember for any users or not. Yes, we'll look into seconds here for any of this. We might use this for terminating threads. Actually, yeah, we'll use this for. Yeah, lasting in our chatting part then is our encoding and decoding. So just know that. Again, we're talking about a network. We're just talking about setting bits and bytes. Usually in programmer world, we were thinking of other things, you know, maybe a text. How do we go from text to bits and bytes? Well, someone kind of encoded or decoding. Usually ASCII or maybe Unicode remember ASCII is just one byte per character. And you unicode, UTF requires one to four bytes per character. So it depends on where you are. I think in the UTF table, how much it requires. I'm high thought it's going to use that by default. Okay, so that's all of our kind of just chatting bits. Everything from here on out is going to be looking at and running code. So let's start by looking at sockets. So in this section, we're going to look at the socket library. It's our lowest level networking thing kind of gives you the experience of. Bang your head against the wall and see, but you're not paying your head against the wall and see if it's not nearly as bad as a C is. So let's start by creating this one called time client.py. So I'm going to go ahead and copy this. I'm going to hop over to my VS code. I'm going to have two VS codes. This is not just often the assortment. I'm going to do a new file in here and we'll call this time client.py. And we'll just paste this guy in here. Unless just chat about what's happening in here. So what this thing is doing, it's importing the socket library. This is where our low level network operations live. Then we're going to go ahead and create an instance of that class. Which for whatever reason is socket dot socket. And then there require a few different arguments to it. The first one is the address type. A F I net, I guess IPV4. And then our socket type is sock stream. And I'm not really an expert at these things. So I don't 100% know what the different socket types are. So yeah, I'm not sure if we'll get multiple examples of this or not. But you can always dig into the socket library and be able to see what some of these different versions are doing. So what this program is going to do is connect to one of these time servers. There's these servers all across the world that basically just broadcast the time to anybody. It even wants to know it. One of these is time dot n i s t dot gov. So that's going to be our host. We want to connect to our host. We want to connect on a port and the port for what they call the daytime service is 13. So we're going to connect to time dot nist dot gov on port 13. So we've set up our socket. We're going to be doing IPV4 and we're going to be streaming. So now she's now who we're connecting to. So connecting takes a two-po, uh, post and port. So we're connecting, um, uh, time dot nist dot gov on port 13. Let me have one of these glorious wild true loops. So is this going to run forever? Right. What we want to do here is we want to start by receiving up to 1024 bytes of data. So our data is going to be a soft dot receive 1024. And if there actually was any data received will be in this loop here. We grabbed some data. Um, we'll go ahead and, uh, decode that data as ASCII. Right. Put it into date and string and then print it out. And if we didn't get any data, then we're going to break. Um, finally, uh, once your socket is done, it's always important to close them, which is your soft dot close. So, uh, we're going to do a little bit of a strange piece of code. Let's go ahead and run it. Uh, I guess I have my terminal in thing here. So let's go ahead and do this guy. We'll do a Python, uh, time underscore client dot five. This is typing. Try it down here. Python. Oh, that's weird. Python, time underscore, client dot p y. So again, raw low level. We're connecting to a server somewhere. Somewhere in the world and they're sending us back these bytes, which we can then decode into 60573, uh, 24, oh, nine, 20, and it is 15, 22, oh, seven. I assume maybe that's grand as mean. Uh, usually that minus six. Right. Yeah. So that would be a less minus six. Uh, so yeah, that's a receiving things. Sure, receiving not too bad, right? Kind of gives you the idea of how sockets work without needing to, uh, worry about the server side of things. Well, let's see that's the next thing we want to do. Let's say, okay, uh, time dot nist.gov is all well and good, but we can do one better. We can be our own time dot nist.gov. Um, uh, there's so, uh, why don't we start by creating a little program, but just can write our current time to the screen. So we'll do that. So let's make a new file called time server. Time server dot pi. I'm just going to bring in a library to grab the time from the computer and write it to the screen. So I'll call this Python time underscore server dot pi. I just go ahead and write the time to the screen, not the same format as theirs, but apparently this is a different standard. Apparently there are multiple standards for sending date time across the internet. This is one of them. Uh, this one is rfc867. I don't know what the time dot nist.gov one is. Um, I guess there's multiple syntax are allowed, right? They show multiple syntaxes that you can use. This one's compliant. So anyways, our time server, our daytime server is going to use this, uh, this protocol. Okay, cool. But that's all well and good printing out to the screen. We don't want to just do that. We want to be like, uh, time.nist.gov where, uh, people can connect to us and grab that time. So again, there's going to be more code here. Let's just copy this and paste it right over this guy. And again, let's run through it real quick here. Well, this is going to be similar to stuff you've seen before, but some is going to be a little bit different. Uh, our socket now, we're going to call it server socket. So we're going to remind ourselves this is a server. Uh, same protocols as before though are a f i net, the IPv4 and streaming. Um, for our local machines name, we're going to do socket dot get host name. Uh, that should show us who we are. What port we are. I don't want to bind, uh, our, um, post and port to, uh, kind of ourselves. Uh, so that, uh, basically this open for connections. And then we want to listen. And this is where I freak out and wonder, you know, I want to find it. Is there anything to mess with my lab? Because the, the, everything's been having, giving me issues lately. I want to say we'd be blocking this. It's a fight on the second. I can knock. I said none of my examples are going to work with the stock. Uh, but, um, well, this still works. Um, but anyway, uh, if this works, we have a port open on, uh, 48,000 is open. People can connect to it. I guess we're only going to be connecting on local posts. So it really shouldn't go with a firewall. Yeah, I see no reason. I wish it allowed us. Uh, okay. So anyway, after that, our client socket and address is what we're going to get when the server socket accept command is called. So when somebody makes a connection with us, we'll get a couple of variables out. We'll get the client's socket and we'll get the address of the client. Uh, we'll go ahead and print that out. I got a connection from our address. And then we'll just do that exact same code we had before. But our difference is that instead of printing out to the screen, we're going to do a send it over our same socket back to the client. Then we're done with that particular client. So we'll just go ahead and close it off, right? So this isn't doing anything with threads yet. This is blocking, right? The suit is one person connects with us. We are hung up. If another person tried connecting this exact same time, they'd probably be lost to eternity. Uh, but that is what it is. Uh, you know, baby steps, right? So, uh, they'll connect. We'll make the, we'll make the, um, uh, connection. Uh, we will give them the time and then we'll go ahead and close off just theirs. But we'll still be open, right? We haven't closed our own one. So it's still there as well. In fact, we actually don't have a mechanism in here for closing our socket, which is not ideal. Um, probably that is a thing you should have done. So, uh, I might run into issues with sockets being left open. They're not closing. Uh, but that need us a problem for a little later. Um, let's go ahead and run this guy. So I'm going to go ahead and open up a new terminal in here. Thank you. Because once we're running a server, you're going to see that it consumes the terminal. And then you really can't use it for anything else. I'm just going to open a power shell here, I guess. Let's do power shell. Let's make this a little bigger. And we're going to run our Python time underscore server dot pi. And once you start running it, it should just be hanging out here. Doesn't appear to be doing anything. Can't remember this is like a demon or a service. It's just hanging out, doing its thing, waiting for people to connect to it. So let's go ahead and connect to it as well. Let's go back to our BS code, maybe. I would just make this smaller. And down here, we will now run our, oh, wait, I guess we actually don't have a way of connecting this yet. Do we? Okay, well, it's running. Uh, we want to connect to it. So why don't we modify our time and time so we can connect to it? So only modification we would need to do is instead of connecting to time.nist.gov. Now we want to connect to ourself, right? So our host is now socket dot pi. So we want to connect to ourself. Right? So our host is now socket dot get a host name. So hop back over to time client. Change. Well, I guess it's port matters too. We change both of these. So grab both of these to fact, I might just do the old copy. Control A paste over. So everything should be good. Should be the same code for 99% of it. Only thing changed was this guy. Right? Let's go ahead and run this guy. Python. Python dot slash time underscore client dot pi. And we should have in fact got time back. But now rather than getting it from time.nist.gov. We did it from ourself. We can check that we did it from ourself by pulling up our power shell here. We're going. And yeah, when we got a connection it showed who we got a connection from. So it looks like this is a private IP address. 192, 168, 561 over this port. Right? So we're going to have a connection. So we're going to have a connection. We're going to have a connection. So we're going to have a connection. So we're going to have a connection. So we're going to have a connection. 561 over this port. Right? So remember how clients always have their own unique port. Let's run this thing again and see if we get a different port. Oh, we are froze now. Now the question is who is frozen is which side is frozen? I might just do the old control. Seeing out both of them. I'm not sure why that guy froze up there. But yeah, we did get a connection before canceled out, which was in a different IP address that before. Or I guess the same IP address with different port has before. Right? Every time we spend up a client, he can choose a report. So it's probably for me to close this thing. I just manually like murder the thing and kill all the services. Probably I do. That feels not great, but it is what it is. We haven't really dealt with cleanly closing things yet. Okay, so that is sockets in a nutshell. Pretty straight forward. Again, not very great. We have some of these little buggy things happening. Things not closing, right? Some that we'll deal with by looking at threads. So let's start by looking at threads next. So threads is our idea of being able to basically take a program and break into little chunks. Send the chunks to different parts of the operating system to manage. It'll do each part and they'll come back. So let's look at a very quick example of it here. What we're going to do is bring in the threading library from Python. And then we're going to do a couple of things. We're going to have create some functions called print cube and print square. And print cube just prints out the cube of a number print square print out the square of the number. And after that in our main thread, what we're going to do, I guess what we haven't really talked about, main threads yet. And Python, if you want to have kind of the equivalent of a C++ main function or, I guess, Java main function, whatever, the way you do that is this if underscore underscore name is double equal to a main with the double underscore or quotes. Inside there, what we're going to do is we're going to go ahead and start two threads. T1 is a threading dot thread. The target is the function called print square and the args is going to be three. Very strange syntax, but it needs to be like this because this threading dot thread needs to be kind of generic enough to work for all sorts of different functions. So first argument will always be the function name or function reference, I guess, pointing into the function. And then that will be a two-ball of args for that function. That's what we do here is when I start our two threads, thread, thread, two is going to start. They're going to do their thing and whatever order feels good to them. And then after that, we're going to join back in and after that when they're both done, they are done. So let's copy this guy. Let's paste it into maybe a brand new one here on this back. We'll screen again. Let's call this thread example or thread demo maybe thread demo dot i. Place this guy in here. And so yeah, really have no guarantee what order things are going to start because these are pretty short functions. Makes sense that almost definitely a square will always finish before a cube. I think this thread is one and cube is two and they're both pretty quick, but just confirm that is true. So we'll do a Python, Python dot slash red, red demo dot pi. And looks like square finish first cube finish second and they joined up. You're going to have a few times and see if they finish in a different order. It could happen, but again, these are pretty simple functions. Unlikely that a lever happened the other way. Why don't we change the order in which we start the need to start to first and what next and see if that changes anything. So yeah, now cube is finishing first again, pretty pretty small, pretty straightforward. So in theory, they could finish any order, but not happening. So let's try doing something else instead. Why don't we try counting all the way up to some type of a number. So we're printing cubes up to some number, right? So for I and range of some number, we're printing out all the cubes up to that number. And print squares up to number for I and some range of some number. We're printing this squares all with that number. And these are a little bit bigger. It could be we'll see them intertwine a little bit. Or again, could be these are still pretty simple. We're not going to see things change. I'm going to overwrite my thread and demo here. And we can rerun it with this. So looks like, yeah, basically we're still starting our squares first cubes next. We're counting all the way up. So looks like it is still finishing this way first. Again, these are pretty, pretty efficient functions. Oh, there we go. Finally got one where square was going for a little bit. And then at some point the CPU said square you're taking too long. Let's give cube a try. So cube ran for a little bit. Then when cube was finished, square got to come back and finish off its thing as well. I do find if you run this a bunch of your computers very responsive, you'll probably generally see it not happen too much. Like probably when like zoom buffers or something, that's when the CPU or the operating system says, hey, things are happening. We got to be fair and getting everybody ish. Stab at this thing and that's when you'll see something like this square running a bit. Thank you, running a bit and square running a bit. Thank you, running a bit. This is kind of the power of multitasking that allows the peers to do multiple things all at once. This is why we can do well. Yeah, multitasking computers. That's why I'm able to have zoom running while also doing Python here. Right. Because we share the workload. We don't just do one thing all the time. We make sure everybody gets their fair staff. So that's friends in a nutshell. Really great for keeping your application responsive. Looks like when I did a bunch of demos on mine last year at some point I got the squares. Then a bunch of cubes then squares finished off. But we also want to look at this idea of race conditions. So let's look at this idea of race conditions next. So I'm going to go ahead and copy this code and then we can talk about it. Maybe we'll call this race demo. Race condition. I always say we're going to call it one thing and I can't live a different thing. So race condition demo. We're going to do here. So we're going to get in for our threading library. We're going to create a global variable called X the easiest way to deal with threads and variables for demonstrating race condition just using global. It's kind of bad, but it kind of is what it is. So what we're going to do is we're going to create a function called increment. Our increment is it's going to say, hey, find that. Find that variable called X the global and just bump that up by one. Right. Now we know from a little example that this thing here, even though it's written as X plus equals one, we know this actually read in X from global. And that's an atomic operation, right. So our thread's going to do that. Then it might ask the OS, do you want me to wait or can I keep going if the AS OS says keep going. Now we're going to say, okay, we're going to bump up my local X by one, bump up my local X by one. And again, that's the atomic. So with that will finish. And then again, it'll ask the OS, hey, I have more to do is okay. Want me to wait or keep going. And let's say the US says keep going. Okay, then we're going to write global X back from my local X, right. Local X. So if we assume an app is also going to be a talk, right. But there is a chance in here that we could potentially break, but potentially. You know, focus could be stolen by something else. Another another thread, good run in here, right. In theory. And did oh for after this time, right. Another thread could run in here. So worst case scenario is if we have a bunch of these increments running in threads, they could all be reading in an X, saving in their global. And then be put to sleep for a while. And then other threads could start working on that same global dealing with it. Eventually they'll wake up their version of access out of date by, you know, the hours and hours in real world, this text of hundreds of millions of seconds, whatever. But that's enough that our count will be way, way, way, way off. Right. So when we write back in, we're going to be writing back in a very old, very long time. Right. So in our thread task we're going to be doing is we're basically just going to be incrementing for looks like it's a hundred thousand and my notes here. So every thread is going to count up our count by a hundred thousand. If we have two threads, we should count to 200,000 three threads to count to 300,000, four threads to count for the thousand, etc. Right. In our main task, we're just going to go ahead and make sure X is our global is set to zero, star of our two threads, let them run, let them join. And then we're going to try and do this whole thing ten times just to see where we end up. Right. Each time we're going to go ahead and print out how high I made it to. And I mean, a perfect world every single one of these times I should make it to 200,000. Right. So let's see if it does. Let's do Python. There. Let's do Python dot slash race condition demo dot I. Okay. That time, everything went good. Good. Good. Oh man. Got to break at some point. It's not going to break for me. Hey, my computer is too fast. Anyone home with a slightly slower computer, actually able to break it. Well, that's very cursed on my laptop. I definitely did break it at some point. We had this example iteration three here where it read in. So probably one of the threads had read in one, one, two, six, two, nine. And then before it was able to, or maybe it incremented or maybe not, but before it was able to do that, that's completely finished, counted up a whole bunch. And that wrote back in writing in some way lower number. Right. So I wonder what I could do to make this potentially. I just add a zero in here. So it happens. We're going to count to a million instead of a hundred thousand. Oh man. Really enough. I wonder if a hundred of newer versions of Python have a way of protecting against raised computers. I feel like they can't, but there's no way they would do that level of analysis. What else could I do? I try and make the computer's leg out somehow. I don't really know how to do that. Usually. I'm going to decrease this down to. I decrease this down to just one. I'm going to make it make a big suit. Still might not happen. Nope. Still not working. Okay. Well, I'm sure some people probably at home are seeing the race condition they happen in happening on my machine. When I did it. So unfortunate. That's not happening here. Not able to demonstrate it, but nonetheless, most times it was working on my machine too, right? Only every once in a while it would raise condition would pop up and it would not get the actual value. So yeah, let's go ahead and look at how we would fix this now is fixed. So I guess you don't really need to worry about it too much. But basically all we're doing is in our increment function. Whenever we want to bump up the variable, we're just going to do a lock first. Right. So where the syntax for is just with lock. We need to create a lock function pass around or lock object and pass around with lock. We grab our global X and bump it up by block. I would just need to pass that lock all the way through. So it's a lock is a threading dot lock. We need to pass that to our thread tasks that will pass it to the increment and the increment will use it. And because both of our threads have access to that same lock function, they'll always be able to check that hey, is anybody using this lock right now? Oh, you are. Okay. Then I guess I just need to wait. Right. I just need to wait. So you can run this and see that it should be fixed now, but again, my machine was fixed anyway. So very cursed that my example is not a not failing the way I'd like to fail. You got to hate that when your code is not failing the way you wanted to fail. So yeah, now it should be very consistent. Okay, so that is the idea of threading how we solve our race conditions. So with servers, we're going to have code that spawns a new thread and generally that's going to run in an infinite loop. There's one thing we might want to do is be able to break out of that infinite loop and that's going to require having a signal sent to our thread to shy down. So our last thread thing to talk about then is signals. Basically a signal will allow us to shut down our thread. So in this little piece here, let's say we had our server, our server active, and this is a signal, which is a threading dot event. And we're going to go ahead and set that event. So we're going to go ahead and pass that to our two different servers. Right? Our two different servers are Bob and Paul and Bob and Paul are just going to be yelling new message out to each other at given delays. Right? One second or two seconds. And they're just going to keep doing that forever. But because of that thread thing, because of that, what do you call it a signal thing? We're adding this code down here. We have this try accept loop basically going to try wild true sleep. So eventually this in theory should run forever. But if ever we have an exception of our keyboard interrupt, the try will break will hop to the accept. We'll attempt to close the threads. We do that by doing the server active dot clear, which will then propagate through to these two guys while server active is set. We'll go to false. These will both close down and then we'll be able to join our threads peacefully and close them. So a little bit nicer. Then just having threads running forever. So let's go ahead and copy this and see what this looks like. A file. So this is Paul and Bob. This guy in here. Anyhow, they're just going to be yelling new message at various intervals. Right. So all they're going to do. So let's go ahead and run this python dot slash. Yeah. So Bob sends a message every five seconds and Paul sends whenever 10 seconds. So they're just going like this forever. And we don't want this thing to run forever. We want to be able to break it out. So we do this with a keyboard interrupt, which is a control C. So we do a control C eventually. The forever loop here will break out. Right. And we will attempt to close our threads clear the threads that'll shut them down. They'll both join in and I've successfully closed our programs. Oh, I mentioned from chat. I missed here a little bit ago. So with locking it in sure so the guys the job down because it's backed by speed. I believe it does. Yeah, I'm pretty sure a lot is not terribly speedy. But I don't exactly know what the performance impact is. I would definitely assume there's going to be some for sure. You have to imagine there's going to be some trade off there. But yeah, I don't know exactly know if we're talking massive amounts of time or relatively small amounts of time. So run it and should run it in a june for notebook and use that time at function and see just how much faster or slower it is. But yeah, you can assume it is going to be slower using the lock for sure. Okay, so what's all this been building to it's all been building to doing some type of a chat application. So we'll start by getting you set up with that by doing a threaded echo client. So if you remember from maybe you wouldn't have talked with us on our classes, but an echo client is basically just a application. A server application that you can send a message to and it will read the messaging and then send it back to you. Basically for network debugging purposes, right? This is a very, very simple network debug thing. Maybe work with this using things like tell net in the past. That kind of thing. So we're going to go ahead and do a echo server here. We have some starting code for our server here. So I'm just going to go ahead and copy this guy and paste it into let's make the go new file and call this guide chat underscore server dot pine. Paste that in here. Oh, this guy's doing is bringing up our port again, we're grabbing our port our PC name, our server IP and our TCP address putting those all together, initializing our. Socket with our kind of just standard settings, finding our TCP address, listening for things and while true what we're going to do is we're going to go ahead and accept connections, right? Print them out, close your connections and disconnect and we also have our way of shutting down here early with our key for interrupt close our server. So this is blocking and looks like it only does a single connection before it shuts down, right? So sub-occommoded a couple of ways blocking stock optimal and only taking one before it shuts down also not optional optimal. So I believe we could tell net to this guy, let's not do that. Let's do the chat client.py instead. So we'll just put that in a new one of these things in here. Chat client.py will paste in this guy and again, this is going to connect to our server and as soon as it connects, it's going to auto-close so not too much fancy stuff happening here right at this second. So let's go ahead and run our server. We'll make one another power shell again here so it's possible to do. I can do two terminals in here as well. Now with that, let's do a power shell. Wow, we have a lot of files. Power shell. Oh, it's just maybe power shell here. We'll do a Python dot slash. Cat server dot by chat underscore server dot by. So it's listing for some connections. Let's just do another power shell. To the right side by side here. Another one. And yeah, same thing. We'll just do our Python. So what do I do? Python dot slash chat underscore client.py. It connected. It disconnected. That's all I did. That's okay. We saw that it made the connection and we saw that it closed and that's all. Actually, I realize now that my suckers are not closing on this machine. So that's unfortunate. I saw that start closing. We do have the server dot close. It's definitely got to be getting there. Maybe this one. Is it because I'm missing a stop. Oh, I think I know what it is. I think it's the fact that we are back at this point right now, which is a blocking connection. I can't keyboard interrupt. I can't get the server close. So we're just hung right now. That's what's going wrong. Unfortunately, because this blocks right. There's no way to get out of this code. Which is why we would need our threats. Right. So unfortunate is what it is. I think we're just stock here. I might shut the close. The power shell and probably probably this this fork is kind of consumed now for some period of time until. Some process running on PC's is hey, you have a open port this bound to nothing and then it goes ahead and close it for me. So you might see that on your own machine. If you try running it again real right away and it just says, hey, this ports in use. So let's go ahead and change our client. So we can send a message before we close it. So I'm just going to go ahead and copy this guy, paste into client. And let's look through our code to see what we've done differently this time. So now in our client side what we are doing is reconnecting to our server. Right. And then wait, there's up the servers. Oh, I mess this up. This should have been the server size. Let's put this in the server and said. These are server side. We are starting ourself up. We are waiting till the person connects. Then we're going to grab a message. We're going to go ahead and decode that message. We're going to print out and they're going to close things and close that connection. And then again, we're unfortunately probably going to be stuck just as what it is. I don't know if it makes sense to do a break in here. Just going to do a break in here. That should break out of the while. Which I think we close the server. I'm going to do that. Hopefully that works. Maybe it doesn't work. We'll see you in a sec. Then let's hop over to the client as well. We actually want to send some stuff as well. What we're going to do is we're just going to use this input function. That's the Python's kind of like see in type function where we tell the user to give us some stuff. The user can give us some stuff. Once we get some stuff, we're going to send that to the client using the send thing. We just go ahead and encode the message and then send it over the socket. I think very complicated happening there. I don't think. Again, we'll do our same service before two power shells. One is our server. One is a client. We'll send it over to the client. We'll send it over to the client. Hopefully I didn't break the server with that break statement. But I guess we'll see in one sec if we did. I really wish that you could be big, but also be on half the screen. I guess you can. There we go. Python.slashchat. We've made our connection to it. Now we want to send a message. Hello network world. That's straight. I did over the server. Server grabbed it from when I took 168.6.1 at this port. Hello network. I'm going to send it over to the server. I'm going to send it over to the server. Server grabbed it from when I took 168.6.1 at this port. Hello network world. We send it back. Did we send it back? I just kept it. We just print it out. We just print it out and then we close touch. We can actually send it back. Is that going to be our next step? We're not quite an echo server. We're echoing into the densest material possible. There's no sound vibrating back at all. So this time we actually want to be able to bounce our messages back to the user. I guess the first thing I do here for doing changes adding in a client can keep sending messages. then close the chat row. Until you send one message into a special message to disconnect or explain point between 2. It feels like I'm still not echoing back. After. This kickbox we'll make at there. Let me go ahead and close these two things bang off. Good. If I had build this way, the eyeballs would work. hadn't used close. We step on aframes workflow that Wie. but still not modifying anything on the echoing side of things yet. This is a server. This is a door of clients. Yeah, I think that's the main change you made. As long as the message was not the disconnect message, then we're just going to keep going on and sending messages to the client. Basically, here to the server, I guess, why'd they client? Oh, right. Yeah, because we're on the client side. So I guess we named the socket as client. We were sending it to the server. I don't know if that's confusing or not. But that was less confusing when I wrote this lab last year. Now, I'll go ahead and make that a little bit confusing. That's what it is. Let's go ahead and rerun these two guys. We have our chat server. Doing this thing. We have our chat client. It's doing its thing. Should be able to send multiple messages now. Hello network world. The shelf shouldn't be bumping back yet. I don't think. How are you today? You are getting multiple messages. That is good. And then we can. This side with the control. But unfortunately, I did not put a break in here. So I think we are again, I think the server is again locked up. Yeah, I should have had a break in. Here, probably where we, if we get the disconnect message, we break out and then close down. But I didn't so we have no choice, which is manually. Smother it to death with a pillow. I think probably is actually turning our server into an Echo server. I was part of the assignment is actually trying to the Echo server. Okay. So I guess we're just trying to implement threads instead. So rather than do the Echo server, I guess that's going to be the first part of the assignment. Oh yeah, it is of course. That makes sense. Right. Because in order to get to the chat, you want to first just by start by bouncing messages back then by bouncing from different people. And then have some quality of light stuff in there. Yeah, I guess we won't get to the bouncing things back. Not terribly hard. So easy first part for you. Instead of we're going to start doing some thread stuff as well. So what we don't want to do next is be able to, let me just make sure I'm leaving off the right place here. Yeah, this is where we're going to bring in the threads here to make it so that every time a client connects, they're able to start sending messages and getting them bounce back. Or I guess not bounce back, but pray it out for now. And then after that we can shut it down with the control C thing. So I'm going to grab this guy here and paste into my server. Chat server. And then the client doesn't need to be changed. I don't think this is purely server side changes, right? Yes. Purely server side quality of life. So let's maybe just take a quick look to see what we've done. So what we did here was we made this function handle client, which is doing all of our client handling stuff. This is going to be a threaded function. Right. Handle client is going to start in a thread. Whenever a person connects to it, we will start that thread up. And add it to our list of threads that are running. And then if ever we get a keyboard interrupt, we should break out and close up our threads as well. Do I have any reason to believe this isn't going to work? Not sure. This may or may not work. We'll see. I feel like I'm slightly suspicious of this now. We'll see. So I don't think we've actually dealt with that blocking guy. Well, I guess we put it in a thread. Are we using the messages to send it to the threads? Should I be? Like we're not. So they still have them bugs in it. But that's okay. Let's go ahead and rerun our server thing. Do a Python chat server. And then we will do a chat client over here. Deplication warning. Active count is deprecated. That's good to know. I'll need to refactor this lab for new version of the Python. Active underscore account. That should be easy fix anyway. I see that things are still working using threads. Yeah, everything is still going okay. Going okay. I kind of feel like if I do the controls, you think over here, it's not going to work because I still don't have anything that communicates the threads that we're breaking out. So we're still just as locked in as we were before. I don't know how I missed that when I was doing this lab up last year. And didn't remember to make a change to it this time. Oh, I guess maybe I knew that. I didn't know that because at this stage, we're successfully setting many messages. As we went onto the server, however, we try to shut down with control. See it still has the thread hanging for any composing. So to do this, we need to add in that thread signal thing, right? We also have this socket dot timeout thing, which whenever we're sitting at that socket place where we just sit there, every certain amount of time would just take a little pause to see if anything else important has happened. Then pop back to it. Check to see if anything of course happened pop out pop back. So basically it's all about how do we get out of being stuck at this line here? Right. How do we get stuck out of being stuck at this line right here? And we're going to do that with the socket time. So there's actually kind of two things we're doing at the same time to kind of break through that. Right. So let's go ahead and copy that guy in and paste into our server. I think this might be the last version before I let you guys loose that right. I know this one more thing. Copy the client guy. This is in what I do to client. Do I do anything different to client? I don't remember. I need to go through this part in more detail again to kind of see where's the thing when I made this. I thought every single part had a useful bit of learning from it, but now I'm kind of questioning faster. We'll need to revise. Let me grab another power show. I think I does it again, smother one to death. Not being able to close things cleanly. I think that should finally be fixed. How to make it decently far to get to that point though. We'll run our server again. We will leave our full client. There was still a rank some reason. Again, I need to fix that active flight thing. Hello. Are you running in one thread? Why don't we go ahead and grab one more power show? We're in the right place. I'm going to go to CD downloads. NC472. Lab 1. Warm. Can we create a mini thread? As far as I know, there's not a limit. Language wise. Probably at some point your computer is not going to love it. Or they call it fork bombing. You keep making more and more threads until you shut down the computer. Maybe Python has something built in to prevent that. I know in the very unix environment, you can make as many threads as you want. I want to do that. I want to do that. I want to do that. In theory, it's possible. I don't want to go to two. I want to run another flight. Python, chat, Now we have two active connections. I will get this guy disconnect with the control. Let's see. Rather than letting this guy go, why don't we do a control. On the side and check our machine. Still not working. I might debug this example a bit more. It could be changes happen since Python. Or maybe I need to be out of all my things. I don't think that would be the case probably. I need to debug this example a bit more to see why it's not shutting down. I'll just close it again. Smother with pillow as one does. And. See what else we have going on here. So last, I think this is the last thing. Yeah, guys, those are our last thing. So our guess our last thing we have been here is that. We've been doing so far. We've always been looking for receiving 1024 bytes. What happens if we try sending a message that's bigger than that? Well, we kind of have an issue. So we need to do what we need to basically break up this thing into a protocol. The protocol should be such that you know the first message we send is how much we're going to send. And the second message we send is actually going to be sending that much. Right. So there are a few ways you could do this. I found a tutorial online that I followed. I have no idea if this is a good strategy or not. It felt like a good strategy for teaching. So it's kind of obvious to explain. So we did was we took a number and we just pad it up to eight bytes. So basically. The first eight bytes represent the message length of the message. So for example, if we have 12, then we can send a message of length 1212123456789101112. So whenever the client types in their message, what they're going to need to do is they're going to figure out how big. I guess the message is going to be right. And then you're going to want to say that in the first number of bytes. We get to use that little cool repeating operator thing here by multiplying the. Just empty byte by the amount of padding needed. And so we can then use that and then send the message of that length with the padding to the client or to the server. And the server will know to do kind of the thing where we unpack the. Or that be unpack the message figure out the length of the message. So sort of process our protocol that kind of thing. And then after that, we want to. Actually, I received the message of the length. So that's kind of our last change for this thing. We can go ahead and run this to see if it's working. I still don't have the control seat that working. So I think I debug that. Paces into chat server. It's the other one into chat client. So we kind of the starting of a protocol happening. And as you do a what do we call it chat service. You will need to actually kind of expand on the protocol a little bit. So it can do a little bit more than just say how many bits you're sending. I might want to say who sending those bytes or you can leave their name. All that kind of stuff that you want to include in the protocol. So I'm going to go ahead and restart my both things. I don't know if I actually see a change on this side with the. Bites. Or if it will just appear to kind of work kind of cleanly. I just got a peer to work kind of cleanly. Oh, is it just straight. Okay. Something is not working. Yeah, so I mean, he needed to debug these examples on the in the lab environment. Here's why they're not working. They're certainly working before. Okay, that's weird. So it did go through eventually. I'm still getting my deprecation where I go fix that. That should be pretty easy to just do a control. I can replace all those things. We got our message. Seems like I'm now getting caught here until I do a control. So that's concerning. I figured out what's going on. Our messages are going across. So yeah, obviously a little bit of you guys can figure out what's going wrong with this example. But anyway, that'll be for me to work on. If you're using the older version of Python, which I was 3.10, you probably won't have those issues. It's probably a newer 3.11 or 3.12 thing is my guess. But I will definitely need to investigate to see exactly where. Where it's freaking out. So the idea for the assignment was basically to be creating an echo service. So we talked about doing it. We started it. We didn't quite get there completely. So the first part would just be to finishing off the echo service part of things. Basically, whenever you get a message to return it back to the client. So I figured this was the easiest way of. Kind of introducing you to multi directional communication. So far, I've only done one direction. We've only ever sent things from one way to the other from the client to the server. That's actually pretty straightforward to send it back the other way as well. So I think that should take a minute. Second part would be the chat service thing. Chat service is. We want to massive modify the applications. So when a client sends a message to the server, it sent to every other client that's connected as well. So now we're not just echoing back to ourselves. We're echoing back to everybody who is connected. Probably should have some identifying information about the person as well. So for example, the address can work. They set it by. So all the things that were being printed out on our side, we want to send back to the other people as well. So I have a couple of hints in here. You can read that when you get there. They'll probably make more sense at that point. The final part is kind of our better chat thing. This will reflect on an application to give people names like your name is Adam or not Adam. I use my example here and they're sending messages in the chat and also sending messages when people join in when people use as well. And the examples down here, you can see what's happening there. So what is this going to be do? I think we have three week break till the next one. I was applying for these labs. I'll be two weeks apart, but it happened that we need to have three week break. I think that right from my ex out later. We are here 20. So we have a three week break until this one is going to be do. And then we'll meet back when we start looking into wire shark. We're actually going to start taking these applications. You've made way them through wire shark and actually looking at the packets that are being sent and see what all is in there. Figure out what's padding, what's our thing. We'll be able to actually investigate the protocol right now. It's kind of we can tell it's working because it's working, but we don't know all the bits that are being sent. So we'll be able to investigate our protocols, see what all is in there. And that will be in October 11th. So I'll do a little bit of debugging on this thing. See if I can find any fixes for it. Because you probably want that code for your starting part here. So I might just fire up a virtual box with 3.12 on my laptop. See if I can get it working there. If I can get it working there, not on the lab machines. Then we're ultra curious because it's a lab issue. Yeah. I guess we'll see. I guess we'll see. So I'll send you the email when I know what is up with why not exactly working the way I want to work. But a lot of the a lot of the things you're going to need to do kind of going forward. I don't know. Maybe it does depend on my example. Maybe I'll just go and make sure it works first. But you guys have three weeks anyway. So I'll get to it pretty quick. And there should be able to email you as soon as I know what's up. Okay, so with that, I guess we will see you then in three weeks. And remember, you can work on these ones in groups of two. So I think they're all a little bit long. So working in partners probably will help. All right. See you folks. Bye.