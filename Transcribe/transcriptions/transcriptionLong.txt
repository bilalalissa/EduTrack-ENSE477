Source: Git & GitHub Tutorial   Visualized Git Course for Beginner & Professional Developers in 2024.mp4
App: Transcription App
Date: 2024-11-01 21:29:37
Duration: 1h 12m 6s
Letters Count: 65560
Words Count: 12232

Outline:
- Introduction
- Key Points
- Conclusion

 Imagine you're working on a coding project and you make a mistake that breaks everything. Your boss would most likely fire you if you were even able to get a job in the first place. Without Git, you'd have no easy way to go back and undo the changes. Your toasted. Git is the industry standard. Most companies, team, and open source projects use Git, so naturally every job description mentions it. Learning Git isn't just the nice to have. It's your Git-Git or Get Out moment. It's a must for any serious developer wanting to land the job. So, hi there, and welcome to a quick, no nonsense Git and GitHub Crash Course. Unlike a typical Git tutorial, which only scratches the surface and leaves you pushing straight to production like many other interns. We'll go beyond the basics and dive into the real stuff. No one really talks about, like how to fix a broken production on a Friday. By the end of this course, you'll not only know how to track code changes and collaborate with your team, but also professionally resolve merge conflicts, fix real-life production issues. Write clean commits so your team doesn't have to question your life choices, recover from major mistakes with reset, revert, and checkout. So, when something breaks production, hand it well, you'll know exactly how to fix it and save the day. Use Git through a GUI so you don't have to memorize tons of commands. And even master advanced Git tricks like cherry picking and stashing because you're here to Git-Git and not just Git-Bye. Basically, with this Crash Course, you'll become your company's go-to-Git Guy. The person everyone turns to when things go south. And there's a lot we'll cover in this video, and I don't expect you to return to it anytime you need to refer to a command. For that reason, I put together the ultimate Git reference guide. Packed with advanced tips and tricks, real-world use cases, and commands to help you level up your Git skills. You can download it for free by clicking the link in the description, and use it as a companion to this course and your career. Let's dive right in. So, what is Git and why is it so popular? Git is a distributed version control system. Sounds fancy, right? Well, let's break it down. The version control part helps you track and manage code changes over time. While distributed means that every developer's computer has a complete copy of the codebase, including its entire history of changes and information about who changed what and when, allowing you to get blame someone. Hopefully people won't blame you, but do you really need it? Can you code without using Git? Well, of course you can, but then your workflow would look something like this. You start coding your project in a folder named MyProject, and as you make progress, you worry about losing your work, so you create copies, MyProjectV1, V2, V3, and so on. Then your colleague asks you for the latest version. You zip up MyProjectV3 and email it over. They made some changes and sent it back as MyProjectV3 John'sChanges.zip. Meanwhile, you've continued to work, so now you have MyProjectV4. You then need to manually compare John'sChanges with your V4 and create a V5 incorporating everyone's work. And then a week later, you realize you accidentally removed a crucial feature in V2. You dig through your old folders trying to figure out what changed between versions. Now imagine doing this with 10 developers. Each working on different features. It's a recipe for chaos, lost work, and countless hours wasted on a version management system instead of actual coding. Git solves all of these problems and more. It tracks every change automatically, allows multiple people to work on the same project seamlessly, and lets you easily navigate through your project's history. No more final version V2, final, really final zip files. Git does all of this for you, but in a much more powerful and organized way. To get started, you need Git installed. Whether on Windows, Mac, or Linux, it's just to click away. Google Download Git. And get it for your operating system. Once Git is installed, open up your terminal. Nowadays, I prefer using a terminal built into my IDE. I'm using WebStorm. And honestly, I prefer it over VS Code because everything just works seamlessly. And WebStorm's Git support is extraordinary. You can do so many things you'll learn about in this video. Everything from creating branches, committing, pulling changes, merging, and even resolving complaints. All without ever leaving the IDE, you can view your Git history, stash changes, and even review pull requests directly inside WebStorm. It makes working with Git, smooth, and intuitive. After walking you through the essential Git commands in the terminal, I'll show you how it can perform the same tasks more intuitively and efficiently using WebStorm. If you're interested in trying it out, I've included a link in the description where you can download WebStorm for free. Just create an account, click download, and go through the onboarding. Once it's set up, create a new project, and you're ready to start coding with all of these powerful Git features built in. First things first, let's check whether you've installed Git properly. Run Git, dash dash version. And you'll get back the version that is installed on your device. Next, you need to configure Git to work with your name and email. This is just a track who made the changes in the project. So your colleagues know who to blame. Here's the command. Git config, dash dash global, user dot name, and then in single quotes, put in your name. Once you do that, you can repeat the same command, but this time instead of changing user dot name, we'll change user dot email. And here you can enter your email, press enter, and that's it. You're all set up. Now let's talk about repositories. A repo or a repository is where Git tracks everything in your project. Think of it like a folder that stores all the versions of your code. Simply put, if a folder is being tracked by Git, we call it a repo. Now let's create a new repository. In your terminal, type Git in it, and press enter. As you can see, Git has just initialized a new repository. On top of the success message, we can also see a warning. In previous times, the default name of a branch has been master, but nowadays you'll see main used much more frequently as the name for the primary branch. So let's immediately fix it by configuring the initial branch name. You can copy this command right here, and at the end, you can just say main. Now considering that we have just changed the initial configuration settings, we have to create a new folder, create a new one called something like mastering Git, open it within your editor, and then rerun Git in it. As you can see here and here, now we're on the main branch. That means that Git has initialized an empty repository. You won't see any changes yet in your folder, but a hidden.Git folder has been created inside your directory. You don't need to touch this folder. Git handles everything inside. From commit history, branches you'll make, remote repos, and more. Most of the time, Git will already come pre-initialized by the framework or library that you use to set up your project with. That's how integrated Git is into every developer's life. So now that we have this main right here, what does that exactly mean? Well, main is the default branch name of your repo created by Git. Every time you initialize Git, this branch will be automatically created for you. I'll teach you more about Git branches soon, but for now, know that a branch is nothing but a parallel version of your project. All right, let's add some files and track changes. I'll create a new file called hello.js. And you can see how smart WebStorm is. It automatically asks me what I want to add it to Git. But for now, I'll cancel that because I want to explain everything manually. Let's make it simply run a console.log that prints hello. Git. Alongside this file, let's create another new file and I'll call it readme.md. In here, we can do something similar and say hello. Git. And now run git status. Git will tell you that you're currently on the main branch that there are no commits yet and that there are two untracked files, one of which is a markdown document. So to track it, use git add readme.md. After adding a file, we need to commit it. Committing in Git is like taking a snapshot of your project at a certain point. Think of it as creating a whole new copy of your folder and telling Git to remember when you did it at what time. So in the future, if anything happens, you'll time travel to this folder with the commit name you specify to git and see what you had in there. It's essential to commit your changes regularly. Regular commits help you keep track of your progress and make it easier to revert to previous versions if you break something. You can commit by running git commit dash m, which stands for message. And then in single quarter strings, you can add that message. For example, add readme.md file. There we go. Congrats. You just created a checkpoint in your project's history. Now let's try running git status again to see what it shows. As you can notice that other file, hello.js, is still there. It's not tracked. We asked git to track only the readme file. To track this file or other files that you may create, we'll have to run a similar command. It'd be too much work to commit each file individually. Thankfully, we have a command that commits all the files we've created or modified that git is not tracking yet. To see this in action, let's create another file. Test.js. And let's add a simple consilog that simply consilogs a string of test. Now to track both files and commit them in a single commit action, we can do that by running git add dot. The dot after git add tells git to add all files created, modified or deleted to the git tracking. Next, as usual, we can specify the commit name for this tracked version by using git commit dash m add hello and test files. There we go. So now we can see that all of these files are tracked. And since I'm using WebStorm, it also has a hidden dot idea folder. So it added it to tracking as well, which I'm okay with. Well done. Now to see the history of all commits we've created, we can use a new command git log. And there we have it our git history. It contains a commit ID or a hash automatically created by git. The author we specified when using git config a timestamp and the commit message we provided. Great. But how do we switch to an older commit and restore it? Let's say the commit add hello and test files introduces some buggy code. And we want to restore our project to a previous version without these files. Our brain would immediately suggest deleting those files entirely or clearing up their code. And if you do that, you'll most likely break your production because other files depend on those files. So instead of deleting them manually to restore to the first version where we had only committed the readme file, we can use a new command. First, you have to copy the commit hash. Yours is going to be different from mine. So make sure to copy yours. I'll get this one first that says add readme and the file and I'll press copy. Then you have to exit this git log by pressing the queue letter on the keyboard. And then you can use a command git checkout and then you can provide a hash of a specific commit or branch you want to check out to now press enter. Okay, something happened. First of all, our two files are gone. Detached head, experimental changes, what's happening? Well, in git, there is a concept of a head which refers to the pointer pointing to the latest commit you've created. When we created our second commit, our head shifted from readme commit to the latest add hello and test files commit. But when we ran git checkout command, we move the head to the previous older commit. That's why we got this detached head warning. It's a state where the head pointer no longer points to the latest branch commit and the rest of this message tells you that you can create a new branch off of this commit. But don't worry, your files are still somewhere. When you use a git checkout command, you're simply viewing the repository state as it was at the time of a specific commit. Like right now, we're viewing a snapshot of your code at a previous moment in time when we only had a readme.md file. The beauty of this is that all the logs and files, whether created or modified, remain untouched. The git checkout command won't delete any logs or history so you can safely explore past states without worry. But what if you actually want to discard changes made after that commit? Maybe you want to quickly roll back to a stable state after an issue hits production? Tidy up messy commits to look more professional or undo a bad push you regret making. Perhaps you've been experimenting with a refactor that didn't pan out or you need to recover from a messy merge conflict. Thankfully, git provides a few commands that will help you in these scenarios. And I'll teach you how all of that works very soon. So just keep watching and we'll dive into these more advanced commands that are really going to help you well fix a broken production. Now to go back to our current state, which is often called the head state, you simply have to run git checkout main. And there we go. Previous head position was at the hash of this checkout and now you switch the branch to main. You can see the same thing happen right here on the bottom right or the top left depending where your branching is. And if you made any changes while in the detached head state and you want to discard them, you can do the same thing git checkout dash f that means force and then get back to main. In this case, we're good. We're already on main and that's it. You already know more about git than most developers do. Of course, we'll dive deeper into advanced use cases and tips and tricks soon. But now let's talk about GitHub and how it differs from git. Git is a tool you use to track changes. Whereas GitHub is a cloud platform that allows you to store your git repositories online and collaborate with others. To push your local project to GitHub, you'll need to link your repository to your remote. But what's our remote? Well, there are two types of repositories. Local repository is a version of a project that exists on your own machine laptop or whatever else you use where you do your developer work. When you initialize a repo using git in it, you create a local repo in your folder. Changes you make there are private until you push them to your remote repository. So a remote repo is a version of a project stored on a server like GitHub, GitLab, or BitBucket. It's used to share code between collaborators and key project versions in sync across different users' computers. When collaborating with a team, you'll have two kinds of repos. Everyone in the team will have a local repository on their machine. And there will also be this one common remote repo from which everyone will sync their local repository versions. Now, head over to githab.com and create an account if you don't already have one. Once you're in, press the little plus icon on the top right and select new repository. Enter a repository name such as mastering git, choose whether you want to make it public or private, leave the ad-readme file checkbox unticked, and click create repository. This is a remote repository. Here, you can see your repository's origin. Copy it. When you clone a repository from GitHub, Git automatically names the remote repository as origin by default. It's basically an alias for the remote repository's URL. Now, our goal is to link our local repository to the remote origin. If you haven't yet switched the default master branch name to main, you can do that by running git branch dash m main. And this will change the branch name to main, which is a standard practice nowadays. And now we are ready to link our local repo to a remote origin. You have to run a command git remote, add origin, and then you have to paste the link to the origin that you just copied and press enter. And a good thing to know is that you can have multiple remote repositories. You just have to rerun the command and change the origin name to something else. Of course, that's the name of your choice. And then you can also update the new URL. But in most cases, you'll be fine with just one remote repo. Finally, to push your local commits to GitHub, use git push dash u origin main. And remember, we used origin here to refer to the remote repository instead of typing the full URL. So press enter and there we go. This worked. If anything with git goes wrong, typically it goes wrong at this point when you're trying to push to a remote repo. So if you don't see what I'm seeing right here, and instead you got some error, typically all of these errors are very easily resolvable. I would just recommend copying the error message, pasting it in Google, and then fixing it right there and then. But in this case, we're good. And now if you go back to your git repository and reload, boom, your code is now online for the world or your team to see. And okay, you might have already known this. For some of you, that's about as far as you've gone with git. Create a repo, push your changes, and call it a day. But git has so much more to offer, especially when you're working within a team. So now let's take things up a notch and dive into branching and merging. This is where git truly shines. Branches and git allow you to create different versions of your project, like making a copy of a project at a specific moment in time. Whatever changes you make in this copied version won't affect the original. The main project or branch stays untouched while you experiment, modify, or add new features in the copied branch. If everything works out, you can later merge your changes back into the original project. If not, no worries. The original remains safe and unchanged. When working in a team, using separate branches for different features or bug fixes is essential. It allows you and your team to work independently on different parts of the code without causing conflicts or errors, ensuring everyone can focus on their own tasks. At the start, you'll have one default branch to create a new branch, run git branch, and then type a branch name. This will create a new branch. And if you want to switch to this newly created branch, then run git checkout. And then enter the branch name you want to check out too. And there we go, switch to branch branch name. Now if you want to go back to main, just run git checkout main. There we go. And here's a little pro tip. There is a shortcut to create a new branch and immediately move to it. To do that, run git checkout with a dash B flag, and then enter a branch name, such as feature branch. Of course, this branch name and feature branch are just dummy names. Make sure your branch name is short and explains which changes will you be making on that branch. For more tips on how to properly name your branches, you can download the git reference guide. So let's create and move to this feature branch in one command. There we go. And what I'm about to say next is very important. So keep it in mind. When you create a new branch, it'll be based on the branch you're currently on. So if you're on the main branch and run the command, the new branch will contain the code from the main branch at that point in time. However, if you're on a different branch with different code, the new branch will inherit that code instead. So to ensure you're creating the new branch from the correct starting point, you should either first switch to the branch you want to base the new one on or run this command git branch, then you can enter a new branch name. And then the next thing can be the source branch. So if you do it this way and replace the new branch name and the source branch with the names of actual branches, then it'll create a new branch from another specific branch. So if you run this command, you can directly create and switch to a branch based on any other branch without needing to check out to it first. For now, I'll remove that. And let's say that we want to go into our code and implement this feature we're working on. Let's say that in our case, the only feature we want to do is to modify the read me. So below hello, git, I'll say I'm adding this from feature dash branch. Here we go feature implemented. If only it was this easy. And you can see that our IDE immediately highlighted this read me file in blue indicating that it has some changes. Now we need to add it, commit it and push it. This time, instead of saying git add read me md, let's just use the git add dot, which is a command that you'll use much more often. Next, we need to commit the changes with git commit dash m and then we have to add a commit message. So this is the perfect time to learn how to write a proper commit message. A quality commit message is written in the imperative mood, a grammatical mood that sounds like you're giving a command. Like improve mobile responsiveness or add a be testing. When writing your commit message, make it answer this question. If apply to the codebase, this commit will and then fill in the blank. Like this commit will upgrade the packages or this commit will fix thread allocation. And why do we do this? Well, because it answers the question, what will happen when I merge the branch containing this commit? It will add a be testing, for example, be direct and eliminate filler words. For example, let's use modify read me in this case. It's short, sweet and in an imperative mood and press enter. There we go. We've just made git aware of our commit. Now that you know how to write better commits, let's take a moment and check out our remote repository. What do you think? We'll have the latest commit we made. Let's reload it and it's the same. It doesn't contain our newly created feature branch. Do you know why? It's because the changes we made are in the local repository, which has not yet been synced with the remote repo. To see those changes, first, you'll have to publish your local branch. And you can do that using the git push dash set dash upstream origin. And then the name of the branch in this case feature dash branch and press enter. There we go. An upstream branch is a remote branch that your local branch tracks. When you set an upstream branch using set upstream, you're essentially linking your local branch to a branch on a remote repo. Through this command, you push a local feature branch to the origin remote repository. And then you set the upstream branch for your local feature branch to track origin feature branch. Alternatively, you can also use git push dash u origin feature dash branch or the name of your branch, of course, both set upstream and dash u establish a tracking relationship between your local branch and the remote branch. This way, in the future, if you want to push something from your local branch to your remote branch, you simply have to run git push. That's it. At this moment for us, everything is up to date, but as you make future changes, you don't have to rerun set upstream or dash u. You only have to add it, commit it, and push it. That's it. And if somebody else made changes to your remote branch either directly or by merging some other changes into it, you have to make your local branch up to date with the remote branch. And you do that by using the git pull command. There we go. It's already up to date in this case. This command fetches changes from the remote repo and merges them into your local repo for that branch. There are also two more advanced and highly practical commands that help you move changes between your remote and local repos. And I'll explain those in detail later on. So keep watching. Now, if you go back to GitHub, check this out. Feature branch had recent pushes a few minutes ago. And if you go to branches, you can see your feature branch right here. So if you click on it, you can see the state of your code base on that branch. And you can see the modifier read me commit that we made. But back on the main branch, it hasn't been modified. It simply says hello git still. So once you have made all of the changes for this branch and implemented the feature you wanted to add and tested it, you'll want to merge it back into the main branch. To do that, you must open up a pull request. A pull request lets you share your changes with your team for review and feedback. Once approved and merged, your changes become a part of the main branch, keeping the code base stable and organized. To open up a pull request, you can click this button right here, compare and pull request, or you can click this pull requests tab right here. Select new pull request, select the branch you want to merge from, such as the feature branch, and then the branch you want to merge to. Here, you can see all the changes you implemented. In this case, we have added one line of text. If the changes look good, you can click create pull request. If needed, modify the title and describe what your PR will do in more detail and then select create one final time. There we go. Now your team lead or senior dev can review your PR and give you feedback. And if everything looks good and there are no merge conflicts, they can merge it. In this case, reload the browser and let's merge it ourselves. Yes, we're sure. Confirm Merge. This is where the magic happens. Your feature will now seamlessly get merged into the main branch. Easy, right? So if we go back to code, you can see that we're now on the main branch and we can see the change from the feature branch. So why does it still say that we have two branches? Well, no worries. Once you merge a PR from a specific branch, GitHub and Git still leave it here for you, but they tell you that your one commit behind main and zero commits ahead, which means that everything this branch was supposed to do in this single commit has been done and it has no additional code that you might want to merge. So it's safe to say that we can delete it. Now, if you go back to code, you can see that there is only one branch, that's the main branch and it contains the newly merged changes. Easy, right? This is how teams collaborate without breaking each other's code. By doing this, GitHub is essentially executing a Git operation in the background. I command that you can do on your own by running Git Merge and then choose a branch that you want to merge, but I typically prefer doing this using GitHub's PRs. Now, if we switch back to our local repo and navigate to the main branch, do you think we'll be able to see the changes we just merged? Well, let's try. Do you remember the command to switch back to main? Well, it's Git checkout and then main. There we go, we switch to main and it says it's up to date with origin main. So if we had to read me, wait, this doesn't look good. It doesn't contain this new line that we added right here and that's because the merged happened on the remote repository, which makes sense, right? So how do we bring those changes into our local repo? Simple, we need to pull them into this branch by running Git pull. There we go. It pulled changes from a remote repo and we can see them right here in our local one. The command we just ran Git pull is just a shorthand for Git pull origin main, but by default, GitHub pulls from the remote origin from the same branch you're currently on. So just Git pull is fine. So let's repeat things. Here is the typical workflow you'll follow most of the time. First, clone the repo. Second, create a new branch from the main or another branch. Third, make your changes. Fourth, push the branch during the remote repository. Sixth, open up a pull request. Seventh, merge the changes. Eighth, pull the merge changes into your local main branch and then repeat from step two. You can also find these steps along with some additional explanations within the Git reference guide. So great job learning about branching. I hope this was intuitive, but next we'll focus on a scary topic, which is resolving merge conflicts. Something that not a lot of people teach you, but you and I will dive deep into it. Sometimes when two or more developers edit the same lines of code, Git gets confused. This is called a merge conflict. When this happens, Git will ask you to manually choose which or whose changes to keep. But why don't the merge conflicts happen when you're working on your project alone? A merge conflict is a situation where Git is uncertain about which part to merge. But why would Git be unsure? To show you what I mean in practice, let me create two branches. First, I'll create a branch called Dev.jsm. So let me run Git branch dev.jsm and press enter. This will only create a branch but not switch to it. Now let's immediately create and switch to another branch. We can do that with a git checkout dash b and then the branch name command. I'll call this one dev. Adrian and you can of course use your own name and press enter. Now I'll make some changes to the code base from the dev. Adrian branch. Specifically, I'll go to read me and I'll change hello git to welcome to git. I'll also add another line and say this is coming from dev. Adrian like this. Now let's add the modified file to git by using git.ad. We can write a meaningful commit message by doing git commit dash m. And let's try to be descriptive of what we did. It's always easier to track the changes that way. So I'll say modify read me by changing the heading and adding a new line. Press enter and at this point everything is looking good. But the branch is of course not yet visible on GitHub since it only exists on our local system. To publish the branch to the remote run git push dash u origin and then the name of the branch dev. Adrian and press enter. The u sets the branches an upstream branch and the origin as you know is the name of the remote repo. If you go back to GitHub, you can see that dev. Adrian has recent changes. So let's open up a pull request. There we go. Modify read me by changing the heading and adding a new line. And creating a new pull request. Great. The pull request is there. Now for just a second, imagine you're not yourself. You are your friend. So let's actually move to your friends branch by running git checkout. And we called it dev.gsm. Remember this branch was created off of the main branch at the time when other you didn't yet add those additional changes. So let's say that your friend also wants to modify the read me. Instead of saying hello git, they're going to say something like hey yo everyone. Welcome to my git guide. And they'll add an additional line and say yo, Johnny here. And they're going to commit their changes by running git add dot git commit dash and of course they don't know how to write quality commit messages as you do. So they're going to write something like today, I woke up and drank some coffee. Then I sat at the table and added a few lines of code. Super long, but doesn't really tell us anything, right? Of course, we have to push that branch by running git push dash you origin dev.gsm or whatever name of the branch you chose. And now our friend is going to come to GitHub and they'll want to open up their port request. So let's do that right away. Their title is so descriptive. It doesn't even fit in one line. And now we have two PRs currently opened. And even though you opened up your PR first, life sometimes isn't fair. So let's say that whoever is supposed to review this PR just didn't want to even see the code that this guy wrote. So they immediately merged it. The key takeaway here is that they merged it before yours got merged. That's great for them. But now if you go to your PR and try to merge it, you'll see something like this. This branch has conflicts that must be resolved. Merging is blocked. Now it is highly likely that whoever is reviewing this won't even start reviewing it until you resolve the conflicts. So they'll most likely write something like Adrian. Please fix these merge conflicts. So what just happened? Why do you have a merge conflict? And most importantly, how can you resolve it? The merge conflict happened because both dev Adrian and dev.gsm made changes to the same file specifically to the same line in the same readme.md file. When the reviewer approved and merged the dev.gsm branch, it created a new commit that made changes to the same line of code that dev Adrian has already modified. Therefore, when you try to merge your branch with the main branch, Git could not automatically resolve the conflict and required you to resolve it manually. In other words, Git was just not sure which version of the code to merge since two different versions existed on two different branches. When Git encounters such a conflict, it expects you as the user to resolve the differences and decide which version to keep and then manually update the code to reflect the changes made in both branches. This is a typical scenario that happens when both you and your teammate are working on the same code simultaneously on the same code at the same time, resulting in modifications to the same line of code and finally causing a merge conflict. It is something that no matter how much you try to avoid it always happens. So you're likely to encounter those merge conflicts from time to time. So how can you resolve them? Well, there is a standard process that you need to follow. With enough practice, it'll become second nature. Here is what you have to do. First, check out the main branch by running Git checkout. Main. Next, pull the latest changes from the remote main branch or in other words, the changes that your friend got merged before you. By running Git pool, there we go. We can see his stupid comments right here. Now your local main branch and remote main branch are identical. So you can safely check out to your own branch. Git checkout dev Adrian. Stop here and let me ask you a question. When you created a pull request, which branch were you attempting to merge the changes into? Well, of course, the main branch. So what are we trying to accomplish here? If you're not sure, let me show you to you in action. Run the command Git Merge Main. That's correct. You have just merged the main branch into your branch. Although the initial objective was opposite, it was to merge your branch into the main branch. But that process didn't work due to the merge conflict. So we first must resolve the issue. And to do that, we're merging the main branch into our branch to identify the problem. The command we just used, Git Merge and then the branch name is used to merge that branch name that you specified right here, such as main in our case, into the branch we're currently on. And now that you run this command, you can see that there are merge conflicts in readme.md. Automatic Merge failed, fix conflicts, and then commit the results. Most code editors have some kind of a versioning system right here on the left sidebar. By pressing command zero, I can open up Websterms1. Here, you'll be able to see a list of all merge conflicts. In this case, we have only one. And it is in the readme.md file. Let me show you how to read it. Aero's pointing to the left side that say head, refer to the changes coming from your branch. And Aero's pointing to the right side that say main, refers to the changes coming from the main branch due to the merge command that you executed. To resolve them, you can manually choose what you want to keep or remove by removing those lines and clearing up the code that you don't want there. But the usual way is to click the resolve button. On Webstorm, it looks like this, but the options should be similar across all code editors. Typically, you have three options. You can choose whether you want to accept your code, whether you want to accept their code, or whether you want to do something in between. Of course, wouldn't life be so simple if you could just choose one of those two options. But typically, that's not what you want to do. In most cases, you'll want to keep some of your code and some of their code. So we'll have to go with the third option. This interface will differ depending on the code editor you're using. Sometimes it might be in line. So you see the red and green lines directly within a single file. But I very much like the way in which Webstorm is doing this. On the left side, we can see our changes. On the right side, we can see their changes. And in the middle, we can see the result. So you can just choose which one you want to merge. In this case, they wrote something that's not so useful. So we want to keep ours. And now that gets transferred over to the middle one. Welcome to get. But let's say that this code is an important implementation of some feature within their branch. Of course, in this case, it's just the line of text. But I think you can imagine how Johnny can really write something useful. So let's say that we also need to merge this. And at the same time, we have also added an important feature from our own branch. So we can add it right here as well. So the final result will look something like this, modified heading, Johnny's feature, your feature, and then the feature that was previously there. Let's remove this stop change from Johnny because we preferred ours better. All changes have been finished and we can click apply. And there we go. Here is our new ReadMe file containing both Johnny's changes and our changes without conflicts. Now, let's open up the terminal run get add dot to add our newly modified file. Say get commit dash M resolve merge conflicts and run get push. You already know the drill, now return to GitHub and check the PR. If you scroll down, you'll see that there is no more merge conflicts because they've been resolved by a resolve merge conflicts commit. Now it would make sense to tag your reviewer and say something like merge conflicts resolved. Please check. Then they'll be able to go through code base, request some changes if necessary. And finally merge your pull to the main branch. Now if you go back to the code, you can see that there's a new commit to the ReadMe three minutes ago and our heading has now been cleaned up. It doesn't include Johnny's nonsense anymore, but it does include their features. It includes your features and it includes features previously added to main amazing work. Now you know how to resolve merge conflicts. One of the scariest things to do as a developer and I know it all looks intimidating at first. But with enough practice, it'll become second nature. Trust me. So far, you've learned the basics and some intermediate get skills that you'll use in your day to day work. But let's be honest, sometimes things can go wrong and you mistakenly break production. That's when Git becomes your best friend. Only if you know how to use it to its full potential of course. And this is where what I call Git savior commands coming handy. These commands let humanity changes, undue mistakes and tweak your commit history. Think of them as your backup plan when things get messy. You're the tried and tested one such command, which allows you to check out to a past commit. Do you know which one is it? Yeah, it's Git checkout and then a commit hash. But as I've told you, that command doesn't discard or delete anything. It's just a way to view the history of specific commits. There might be the case where you want to check out to a particular commit and then delete everything that comes after it. That's the job for Git reset. Imagine you want to remove some commits and revert to a previous commit with the possibility of choosing whether you want to keep or discard the changes in the working directory. That's a bit hard to understand, right? So let me say that again, suppose you made 10 commits and want to check out the third commit in history. You want to delete all commits after the third, like fourth, fifth, sixth, tenth, and so on. Maybe you even wrote some bad code in those commits. And to keep things simple, you want to remove these bad commits, but still want to keep the changes that you implemented. I hope that makes sense. So delete these commits, but keep all the changes you made from the fourth to the tenth commit. This is where we use Git reset. It allows us to remove the traces of commits in history, but gives us the changes we made in those to be discarded commits so we can decide what to do. We can keep those changes, form a better commit out of them, or delete them entirely. It's up to you. Let me quickly add a cons-alog to this hello.js file. On top of the first one, I'll add another one that says something like cons-alog. Hello GitHub. There we go. Now we have to then make a commit by running git add dot git commit dash m add GitHub cons-alog to hello.js. Next to properly illustrate how we'll use git reset, I'll add one more cons-alog. This cons-alog will say something like hello from and then put the name of your branch, dev Adrian in my case, since we haven't switched from before. We're still in this branch. And I also want to commit this. Imagine this is a bigger feature that you implemented. So I'll run git add dot git commit dash m and we'll say something like add hello cons-alog to hello.js and commit it. Now you commit it, you stand up from your desk, go for a walk or go about your day, then you come back and then you start focusing on some additional functionalities within the same branch. Let's say that additional functionality is another cons-alog, but this time this cons-alog will actually break things. So we can say this is bad code. Okay. And now we can do another commit. Of course, without knowing that this commit breaks the code. So we can say git add dot git commit dash m and we can say add another cons-alog. Now if you run git log, you'll see many commit bits. Keep in mind that git log here includes all commits that have happened before as well. Everything from the latest cons-alogs to previous ones to resolving our merge conflicts, even Johnny's changes right here. There's a lot of stuff that's here. Everything from when we first started working on this project. Now before I tell you how to remove this bad code using git reset, you must understand that there are a couple of different ways to run the git reset command. Soft reset simply moves the specified commit in history, but keeps changes staged in a working directory. That means that whatever changes were made after that commit will be in stage mode. And stage changes are those that we add to git tracking system by running the git add dot command. So before running that, they're untracked and then once you run git add, then you can consider those changes tracked or staged. So if you want to do that, you can run git reset dash dash soft and then add a commit hash. The second way to use git reset is called a mix reset. And for that one, you don't have to pass any flag as it's the default one. Mixed reset moves to the specified commit in history, unstages the changes and keeps them in the working directory. Thus all changes made after the specified commit will be in your working directory, but they won't be staged. You have to manually stage them if you want to by using git add dot. And finally, there's a hard reset. It moves to the specified commit in history and discards all changes in the working directory and staging area. All those changes made after the selected commit will be discarded entirely and you won't see any trace. You can run that command by running git reset dash dash hard and then add a commit hash. Now, let's actually go with the mix reset by copying one of the commit hashes from here. But which one do we want to copy? We can scroll to the top to see the newest ones. And we have this add another cons log, which we know breaks her code. So we want to avoid this. So instead, we can go all the way to add github cons log to hellojs. So let me copy this commit hash and press Q to exit git log. Next, we can run git reset and then paste this commit hash and press enter. Unstates changes after reset hellojs. So take a quick look at the file explorer. You'll see that the hello.js file is blue, which means that we have some changes in that file. And if you pay attention to this green line here, this means that these are the two additional changes, which are currently unstaged. So let me put that in other words. The changes for the two commits that we have added are right now here and are unstaged. And we can verify that by running git log. And you can see that there are no additional commits after the add github cons log. There's no add hello dev Adrian and there's no add bad code. We can exit that for a second. And we can also run git status. And you'll see that hellojs has been modified. And specifically, it has been modified with the file changes that came from the two commits that we have reset. So now it's completely up to you whether you want to keep those changes, modify them and then again stage and commit them. In this case, I will simply remove them from the code like they never happened. And we can go to git log and see that there's no more add buggy code or add cons log and see that those two additional commits happening after the github cons log are completely gone. All of your mistakes completely deleted. I hope this makes sense. So you can take a moment and try the other two variations of the git reset on your own and see how they differ. Once you do that, we can move to the next advanced git command. Git revert. Let's say you've deployed a feature that broke production and you want to undo its effects without losing the commit history. You want the logs to be there, but you want to revert to an old commit. This is the exact situation where you want to use git revert. It's ideal when you have nothing to hide and you want to maintain a clear record of changes that you did. It's almost the opposite of reset. Let me show you how it works. I'll add another cons log that says something like trying out revert. Okay. And I will commit it by running git commit bash m add revert cons log. Oops. I forgot to do a git ad before that by mistake. Let me do git ad dot and I'll use the up arrow two times to get back to the previous command and commit it. Now let's say you want to revert to the previous version of your code base that didn't contain this cons log, but you want to keep it in the logs. You can run git log. You can find the commit hash of the previous commit without containing the revert cons log, copy it, and then run git revert, paste the commit hash, and then we get something that looks like this, which is somewhat familiar to us. It's like a mini merge conflict. It's trying to figure out what we want to keep and what we want to remove. In this case, I'll manually remove lines of code that we don't need. So we don't need these ones. And we don't need the trying out revert because we want to abort or revert that one. You can save it. And once you save it, we want to add those changes to staging by saying git ad dot. And then you can run git revert continue and this command will successfully finalize the revert. As you can see, we're getting there. This message is saying that we will revert this commit, but we just need to provide it a commit message or we can exit this window by pressing colon QA and then exclamation mark and then press enter. There we go. So one file has changed. There's one insertion and two deletions and we're back to where we were. Similar to get reset, right? But now if you check out git log, you can see that a new commit revert ad GitHub cons log to hello has been added to our git history. As I said, similar to reset, but depends whether you want to hide your tracks or you want to show everybody that you messed up and you fixed it later on. Both have their own use cases. Now let me show you git stash another super useful git command. Let's say you're in the middle of developing a feature, but an urgent bug caused by your teammate comes up and your boss wants you to work on it first. You haven't finished your feature and it's not ready to commit yet. But you still have to keep your active changes somewhere so you can get back to them later on and you can start working on this bug soon. And that's exactly what git stash does. It lets you temporarily save your uncommitted changes, both staged and unstaged without actually committing them. Let's say that I am in the process of implementing an important feature and then I have multiple lines of code which I don't want to lose. That's going to look something like this. You can also write some of your own very important code here. So now how do we save this code so we can use it later on so we can focus on something else for the time being. It's super useful. You just run git stash. As you can see, your important code is now completely gone and we got a message here saying that save the working directory on dev Adrian. So now you can go ahead and implement this urgent fix that your boss requested you to do. You can then run git add git commit and say save the day. Of course, this is not a realistic commit message, but in this case, since you implemented the urgent fix, you indeed did save the day and you can even push that code if you want to. So you can run git push. Great. The day is saved, but now you want to get back to implementing that other feature you were working on before your day was ruined by a bug. To get our code back, simply run git stash apply and then enter a stash name. But how do we get to a stash name? You can run a command git stash list to see a list of all stashes. Currently, we have stash at curly braces zero. So let's do just that git stash apply stash at curly braces zero and press enter. And you can see that our code got back right here. Since the implemented fix was on similar lines as their existing code, we have yet another merge conflict. But by now, you should be an expert in resolving those. So simply remove the lines around it and keep both the urgent fix and your work in progress. And that's it. The day is saved and you can continue working on your feature. I don't want this to happen, but I'm sure that someday soon you'll encounter an issue in your code that requires you to use one of these three very handy git commands. Git stash will definitely be the first one. So when the time comes, you'll know how to use it. Great work. Although commands like git add commit push merge checkout stash and others may seem hard to remember, even though there is simple, once you get a hang of them, there is an alternative method. As developers, we always discover more efficient techniques for accomplishing repetitive tasks. So let me introduce you to a completely different approach for executing these git commands. Before I teach you these very powerful techniques, do remember that it is still super important to understand the behind the scenes of how these commands work. And that's what you've learned so far, which makes you ready to utilize the power and simplicity of this new approach. I'm referring to using git through a GUI, a graphical user interface. It doesn't require memorizing commands, but instead offers a more visual and user-friendly approach to version control, allowing you to execute git commands through simple buttons, panels and menus. Many editors and IDEs offer git integration through a GUI, but their functionality is limited compared to WebStorm's features. So I highly recommend downloading WebStorm. It's free and packed with powerful git integrations, but if you prefer not to, no worries, you can still follow along with the video and check if your editor supports some of the features that I'll be showing in WebStorm. We can start from scratch by creating a completely new folder and create a new readme.md file within it. There we can say something like testing git through a GUI, a graphical user interface. First things first, let's turn this folder into a git track repository. On the top left or the bottom right, you can click version control and then create a git repository. Open up the current folder and immediately this folder will be turned into a git repository. This is the same as running the git init command. And immediately you can see that right now you're in the main branch. I actually prefer having this on the bottom right, so I'll press command shift B, then I'll search for toolbar and I'll hide it. If you hide the toolbar, then its details will appear at the bottom right. So right now you can see all of the branch details here. Now that we have initialized the git repo, let me show you how you can commit using a GUI. You can go to the bottom right corner and then simply click commit. It'll immediately lead you to this menu showing you all the unversion files. You can select all of them and then add a commit message. I'll say initialize the repo and I will commit the changes. It is as simple as that. Now if you click on the main branch once again, you'll see that you also have the possibility to create a new branch. So let me show you how to do that. You just press new branch and enter a branch name. Let's do something like new dash branch. And it even asks you whether you want to check out to it immediately. For now I'll untick that and click create. So since we haven't moved to it immediately, how can we move to that branch now? Well you can see this little pop-up telling us that a branch new branch was created. So we can click here and here you can see the new branch. But an even easier way to switch to it is to click at the bottom right or the top left and then simply select the branch when I move to and click checkout. And that's it. You are on your newly created branch. I love how WebStorm conveniently organizes these branches into recent, local and later on will even have remote. So you always know at which versions of your branches you're working on. But of course that begs the question how can we push these branches to remote? We usually use the command get push-u origin and then the branch name. But with WebStorm, you can do it in a single click. Just click push. Click define remote and you'll have to enter the URL of your remote origin. To get it, I'll create a new repo and I'll call it WebStorm underscore get and click create repository and I'll simply copy the URL. Back in the code, I'll paste it, click okay and click push. Check this out. All of your code has been pushed to the new branch and now a new origin new branch also exists and it even asks you whether you want to immediately create a port request. I won't do that yet. First, I want to teach you how we can add a few more commits to our readme. So I'll add a new line and then simply say commit one. Then you can either go to this commit icon on the left side and then select it and then modify the commit message and simply press commit. Or let's add another one commit to you can also go to the bottom right and simply click commit there which is going to lead you here and you can add a commit to this time. Let's check how the second option which allows you to immediately commit and push. It's going to ask you to which branch you want to push in this case. We want to push it to the new branch. So let's simply click push and in a matter of seconds, all of those commits are right there. Of course, if you committed some changes earlier like I will do in this case commit three, add it and then add commit three and then later on you want to push them you can go to the bottom right select push from here and repeat the same steps. It is super convenient. Now what about pulling some changes? Let's say that somebody else comes to your repo and inserts an additional message like a commit four right here and updates the read me. How would you get access to that change directly within your repo? Well, typically you would have to run get pool but by using WebStorm you can just go here and press update project. It's going to ask you whether you want to merge incoming changes into the current branch or whether you want to rebase which will rewrite the commit history by rebasing your current branch onto another branch effectively moving it to a new commit. In this case, we don't need to rebase we'll just merge it into our current branch. So just press OK hand in a matter of seconds the commit for that another person pushed is right here within our local repository. What about viewing history? Well, let me show you something really cool. Look for the get icon at the bottom left. This one here if you click it and expand it you'll see a ton of different get functionalities. You can see the exact changes that were made in this repo who created them and when all within this nice looking graphical user interface and within here you can do everything and more that you can do with typical get commands all by choosing one option from a menu that is in English. No obscure commands if I open up the repo for JS mastery that pro platform it is super convenient seeing exactly what is happening within our projects. We can see what changes were made who made them when and whether the tests have passed check this out you can even see the merges that were happening this makes it super easy to go back to previous versions of your code base if needed in addition to this if you press here and then you press console you can see all the commands that web storm is running for you of course you know some of these base ones but some of these more complex one well it's going to be easier to do it using a GUI. Now how can we use web storm to merge one branch into another typically we would have to create it and then run get merge command to merge it into another branch in this case select a main branch and press this arrow right here it's going to allow you to merge main into new branch or vice versa. Similarly if you click the arrow on this branch you can easily create a new branch from this branch or you can update it in this case let's go to main and let's merge main into the new branch in this case it says it's already up to date so we're good but what about pull requests one of web storm's coolest features is that it allows you to do all sorts of tasks directly within the IDE you don't need to use GitHub desktop or even GitHub to perform different actions everything you need is right there so let's talk about creating a pull request on the left side you can find a pull requests tab for you it might be a bit of a different icon in this case it's a GitHub icon for me within here you can do everything PR related so let's open up a new pull request in this case we want to merge the new branch into the main branch but before we do that we have to first create a remote origin version of the main branch so let's do that first I'll head over to main by checking out to it and I'll simply push it push to origin main it is as simple as that we can immediately now use this create pull request feature to move us to this pull request menu we want to merge from branch new branch where you can choose origin new branch to origin main exactly what we wanted to do you can add a title of this pull request such as implement for commits because that's what we added into the read me description is not needed and directly from here you can add reviewers as I need and labels in this case I'll just click create pull request and there we go it is if you go to GitHub and click pull requests you can see the new pull request indeed has been opened the next cool thing is that you can see exactly the changes that were implemented for each specific commit so if you go here you can see that first at some time they added a commit one then later on they added commit to and so on but now we're interested in all commits so now you can review the changes that were made for each file separately first we want to dive into the read me.md file so right click it and then it'll open up a diff a diff or a difference refers to the changes of a specific file on two sides of the coin or should I say on two different branches one is the branch that we're trying to merge and the other one is the branch we're trying to merge the changes too you can view those things either split like this or unified in a single editor and based on the green or red color you can see the changes that were made in this case I'm happy with the changes and I'll click submit and if you're a reviewer you can immediately add a review directly within web storm you don't have to go to GitHub just by pressing a plus here you can add a comment something like fix this line and you can even start a review there we go finally you can submit your pull request review and you can add one final comment looks good to me great finally if everything looks good you can press the three dots next to the request review button and then say merge review merge merge pull request one it'll implement four commits that's the title of the pull request and we can say merge believe it or not this is it so now on main you can simply update the project and all of these commits will come directly to your code base I mean just how convenient and intuitive and efficient this is at start you might feel like you are kind of cheating the system or that you are a bit of a less of a developer by using this help that web storm provides but don't feel that way any tool that can make you more efficient is welcome and what matters is that you understand what web storm is doing behind the scenes and you do because you came to this point of the video I think that in just a couple of minutes I've showed you all of the primary functionalities that before using the terminal I spent more than an hour to explain and we've accomplished all of that and more in just a few minutes but there are so many more things that you can do with web storm one of these things is a fetch if you see this icon on top right you can just click it and it'll fetch all the latest changes another thing is how easily you can delete branches we no longer need this one since we merge the changes so you can just press delete here we go that was it you can also compare different branches mark branches as favorite or even cherry pick from a specific commit if I go right here to get at the bottom left and go back to log we can see all of these different commits that I added cherry picking is a very advanced technique but in web storm it is as simple as clicking this cherry pick icon you click it and it'll allow you to pick the changes from this commit you can press merge and then you can see which changes you want to accept this is similar to reverting or resetting to a specific commit but it gives you even more power to pick and choose which features you want to keep and which ones you want to remove you can also rename different branches or even revert to specific commits directly from within this view typically you would have to get the commit hash figure out what you want to do here you just press revert commit and that's about it we cannot do it now because we have unstayed changes but that's also pretty easy to resolve once you have web storm you just go here and you can easily resolve all the conflicts and then commit and when a technology is so good that it feels like magic based on how many things is it doing for you and it's doing them well well it almost feels like magic for us developers so whichever complicated feature you want to use you can use it within web storm with ease these were just a few examples of how we can use the web storm GUI to perform many different git operations without needing to rely on a single git command and that's only one of the reasons why I love web storm while you can accomplish some of these tasks in other editors not all of them are possible as there's a clear difference between an editor and an IDE right so go ahead and explore other options try breaking some things fixing them reverting resetting cherry picking you can only get better at something by trying it out yourself I'll also leave a reference on how we can use all of these features within the git reference in the description of this video but with that in mind we covered a lot about git if you're still with me and you have successfully completed these git actions with a solid understanding and even tested them out yourself congratulations you can confidently add the skill to your resume length and profile or anywhere you're applying for a dev role and don't worry if you're not feeling fully confident yet or are concerned about remembering everything git can be tricky at first but with practice it'll become second nature especially once you get used to these graphical user interfaces but still it's easy to get stuck and lose your mind about something especially when you have to pull some very obscure commands out of your pocket so for those situations don't forget to download the cheat sheet in the description so you can have a handy reference whenever you need it in the future and great job with sticking till the end of this essential crash course thank you so much for watching and I'll see you next time have a wonderful day